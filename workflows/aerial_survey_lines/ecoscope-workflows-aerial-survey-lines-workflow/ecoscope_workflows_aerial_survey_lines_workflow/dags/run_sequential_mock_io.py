# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details

# ruff: noqa: E402

"""WARNING: This file is generated in a testing context and should not be used in production.
Lines specific to the testing context are marked with a test tube emoji (ðŸ§ª) to indicate
that they would not be included (or would be different) in the production version of this file.
"""

import json
import os
import warnings  # ðŸ§ª
from ecoscope_workflows_core.testing import create_task_magicmock  # ðŸ§ª


from ecoscope_workflows_core.tasks.config import set_workflow_details
from ecoscope_workflows_core.tasks.filter import set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers
from ecoscope_workflows_ext_ecoscope.tasks.results import set_base_maps

download_roi = create_task_magicmock(  # ðŸ§ª
    anchor="ecoscope_workflows_ext_ecoscope.tasks.io",  # ðŸ§ª
    func_name="download_roi",  # ðŸ§ª
)  # ðŸ§ª
from ecoscope_workflows_ext_ste.tasks import generate_survey_lines
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polyline_layer
from ecoscope_workflows_ext_ecoscope.tasks.results import draw_ecomap
from ecoscope_workflows_core.tasks.io import persist_text
from ecoscope_workflows_core.tasks.results import create_map_widget_single_view
from ecoscope_workflows_core.tasks.results import gather_dashboard

from ..params import Params


def main(params: Params):
    warnings.warn("This test script should not be used in production!")  # ðŸ§ª

    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    initialize_workflow_metadata = (
        set_workflow_details.validate()
        .handle_errors(task_instance_id="initialize_workflow_metadata")
        .partial(**(params_dict.get("initialize_workflow_metadata") or {}))
        .call()
    )

    define_time_range = (
        set_time_range.validate()
        .handle_errors(task_instance_id="define_time_range")
        .partial(
            time_format="%d %b %Y %H:%M:%S %Z",
            **(params_dict.get("define_time_range") or {}),
        )
        .call()
    )

    configure_grouping_strategy = (
        set_groupers.validate()
        .handle_errors(task_instance_id="configure_grouping_strategy")
        .partial(**(params_dict.get("configure_grouping_strategy") or {}))
        .call()
    )

    configure_base_maps = (
        set_base_maps.validate()
        .handle_errors(task_instance_id="configure_base_maps")
        .partial(**(params_dict.get("configure_base_maps") or {}))
        .call()
    )

    fetch_roi_layer = (
        download_roi.validate()
        .handle_errors(task_instance_id="fetch_roi_layer")
        .partial(**(params_dict.get("fetch_roi_layer") or {}))
        .call()
    )

    draw_survey_lines = (
        generate_survey_lines.validate()
        .handle_errors(task_instance_id="draw_survey_lines")
        .partial(gdf=fetch_roi_layer, **(params_dict.get("draw_survey_lines") or {}))
        .call()
    )

    persist_aerial_gdf = (
        persist_df.validate()
        .handle_errors(task_instance_id="persist_aerial_gdf")
        .partial(
            df=draw_survey_lines,
            filetype="gpkg",
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            **(params_dict.get("persist_aerial_gdf") or {}),
        )
        .call()
    )

    persist_aerial_geoparquet = (
        persist_df.validate()
        .handle_errors(task_instance_id="persist_aerial_geoparquet")
        .partial(
            df=draw_survey_lines,
            filetype="geoparquet",
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            **(params_dict.get("persist_aerial_geoparquet") or {}),
        )
        .call()
    )

    aerial_survey_polylines = (
        create_polyline_layer.validate()
        .handle_errors(task_instance_id="aerial_survey_polylines")
        .partial(
            layer_style={"get_width": 2, "width_unit": "pixels"},
            geodataframe=draw_survey_lines,
            **(params_dict.get("aerial_survey_polylines") or {}),
        )
        .call()
    )

    draw_aerial_survey_lines_ecomap = (
        draw_ecomap.validate()
        .handle_errors(task_instance_id="draw_aerial_survey_lines_ecomap")
        .partial(
            tile_layers=configure_base_maps,
            static=False,
            max_zoom=12,
            north_arrow_style={"placement": "top-left"},
            legend_style={"placement": "bottom-right"},
            geo_layers=aerial_survey_polylines,
            **(params_dict.get("draw_aerial_survey_lines_ecomap") or {}),
        )
        .call()
    )

    persist_ecomaps = (
        persist_text.validate()
        .handle_errors(task_instance_id="persist_ecomaps")
        .partial(
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            text=draw_aerial_survey_lines_ecomap,
            **(params_dict.get("persist_ecomaps") or {}),
        )
        .call()
    )

    create_aerial_widgets = (
        create_map_widget_single_view.validate()
        .handle_errors(task_instance_id="create_aerial_widgets")
        .partial(
            title="Aerial Survey Lines",
            data=persist_ecomaps,
            **(params_dict.get("create_aerial_widgets") or {}),
        )
        .call()
    )

    patrol_dashboard = (
        gather_dashboard.validate()
        .handle_errors(task_instance_id="patrol_dashboard")
        .partial(
            details=initialize_workflow_metadata,
            widgets=create_aerial_widgets,
            time_range=define_time_range,
            groupers=configure_grouping_strategy,
            **(params_dict.get("patrol_dashboard") or {}),
        )
        .call()
    )

    return patrol_dashboard
