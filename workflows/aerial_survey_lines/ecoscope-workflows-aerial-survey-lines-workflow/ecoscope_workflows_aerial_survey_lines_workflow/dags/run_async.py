# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details
import json
import os

from ecoscope_workflows_core.graph import DependsOn, DependsOnSequence, Graph, Node
from ecoscope_workflows_core.tasks.config import (
    set_workflow_details as set_workflow_details,
)
from ecoscope_workflows_core.tasks.filter import set_time_range as set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers as set_groupers
from ecoscope_workflows_core.tasks.io import persist_text as persist_text
from ecoscope_workflows_core.tasks.results import (
    create_map_widget_single_view as create_map_widget_single_view,
)
from ecoscope_workflows_core.tasks.results import gather_dashboard as gather_dashboard
from ecoscope_workflows_core.tasks.skip import (
    any_dependency_skipped as any_dependency_skipped,
)
from ecoscope_workflows_core.tasks.skip import any_is_empty_df as any_is_empty_df
from ecoscope_workflows_ext_custom.tasks.io import load_df as load_df
from ecoscope_workflows_ext_custom.tasks.results import (
    create_path_layer as create_path_layer,
)
from ecoscope_workflows_ext_custom.tasks.results import draw_map as draw_map
from ecoscope_workflows_ext_custom.tasks.results import (
    set_base_maps_pydeck as set_base_maps_pydeck,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df as persist_df
from ecoscope_workflows_ext_ste.tasks import (
    combine_deckgl_map_layers as combine_deckgl_map_layers,
)
from ecoscope_workflows_ext_ste.tasks import (
    create_deckgl_layer_from_gdf as create_deckgl_layer_from_gdf,
)
from ecoscope_workflows_ext_ste.tasks import draw_survey_lines as draw_survey_lines
from ecoscope_workflows_ext_ste.tasks import (
    generate_survey_line_colors as generate_survey_line_colors,
)
from ecoscope_workflows_ext_ste.tasks import get_file_path as get_file_path
from ecoscope_workflows_ext_ste.tasks import get_gdf_geom_type as get_gdf_geom_type
from ecoscope_workflows_ext_ste.tasks import view_state_deck_gdf as view_state_deck_gdf

from ..params import Params


def main(params: Params):
    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "workflow_details": [],
        "time_range": [],
        "groupers": [],
        "configure_base_maps": [],
        "retrieve_file_params": [],
        "load_gdf": ["retrieve_file_params"],
        "assign_geom_type": ["load_gdf"],
        "generate_layers_map": ["assign_geom_type"],
        "survey_lines": ["load_gdf"],
        "persist_aerial_gdf": ["survey_lines"],
        "persist_aerial_gpq": ["survey_lines"],
        "assign_survey_colors": ["survey_lines"],
        "aerial_survey_polylines": ["survey_lines"],
        "zoom_gdf_extent": ["load_gdf"],
        "combine_map_layers": ["generate_layers_map", "aerial_survey_polylines"],
        "draw_aerial_survey_lines_ecomap": [
            "configure_base_maps",
            "combine_map_layers",
            "zoom_gdf_extent",
        ],
        "persist_ecomaps": ["draw_aerial_survey_lines_ecomap"],
        "create_aerial_widgets": ["persist_ecomaps"],
        "patrol_dashboard": [
            "workflow_details",
            "create_aerial_widgets",
            "time_range",
            "groupers",
        ],
    }

    nodes = {
        "workflow_details": Node(
            async_task=set_workflow_details.validate()
            .set_task_instance_id("workflow_details")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("workflow_details") or {}),
            method="call",
        ),
        "time_range": Node(
            async_task=set_time_range.validate()
            .set_task_instance_id("time_range")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "time_format": "%d %b %Y %H:%M:%S %Z",
                "timezone": {
                    "label": "UTC",
                    "tzCode": "UTC",
                    "name": "UTC",
                    "utc_offset": "+00:00",
                },
                "since": "2026-01-01T00:00:00Z",
                "until": "2026-02-28T23:59:59Z",
            }
            | (params_dict.get("time_range") or {}),
            method="call",
        ),
        "groupers": Node(
            async_task=set_groupers.validate()
            .set_task_instance_id("groupers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("groupers") or {}),
            method="call",
        ),
        "configure_base_maps": Node(
            async_task=set_base_maps_pydeck.validate()
            .set_task_instance_id("configure_base_maps")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("configure_base_maps") or {}),
            method="call",
        ),
        "retrieve_file_params": Node(
            async_task=get_file_path.validate()
            .set_task_instance_id("retrieve_file_params")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("retrieve_file_params") or {}),
            method="call",
        ),
        "load_gdf": Node(
            async_task=load_df.validate()
            .set_task_instance_id("load_gdf")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "file_path": DependsOn("retrieve_file_params"),
                "layer": None,
                "deserialize_json": False,
            }
            | (params_dict.get("load_gdf") or {}),
            method="call",
        ),
        "assign_geom_type": Node(
            async_task=get_gdf_geom_type.validate()
            .set_task_instance_id("assign_geom_type")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("load_gdf"),
            }
            | (params_dict.get("assign_geom_type") or {}),
            method="call",
        ),
        "generate_layers_map": Node(
            async_task=create_deckgl_layer_from_gdf.validate()
            .set_task_instance_id("generate_layers_map")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("assign_geom_type"),
                "style": {
                    "get_fill_color": [85, 107, 47],
                    "get_line_color": [85, 107, 47],
                    "opacity": 0.15,
                    "stroked": True,
                    "get_line_width": 1.25,
                },
                "legend": {
                    "title": "Legend",
                    "values": [{"label": "Area of Interest", "color": "#556b2f"}],
                },
            }
            | (params_dict.get("generate_layers_map") or {}),
            method="call",
        ),
        "survey_lines": Node(
            async_task=draw_survey_lines.validate()
            .set_task_instance_id("survey_lines")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("load_gdf"),
            }
            | (params_dict.get("survey_lines") or {}),
            method="call",
        ),
        "persist_aerial_gdf": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_aerial_gdf")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "filetype": "gpkg",
                "filename": "aerial_survey",
                "df": DependsOn("survey_lines"),
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_aerial_gdf") or {}),
            method="call",
        ),
        "persist_aerial_gpq": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_aerial_gpq")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "filetype": "geoparquet",
                "filename": "aerial_survey",
                "df": DependsOn("survey_lines"),
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_aerial_gpq") or {}),
            method="call",
        ),
        "assign_survey_colors": Node(
            async_task=generate_survey_line_colors.validate()
            .set_task_instance_id("assign_survey_colors")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("survey_lines"),
                "hex_value": "#ffa500",
            }
            | (params_dict.get("assign_survey_colors") or {}),
            method="call",
        ),
        "aerial_survey_polylines": Node(
            async_task=create_path_layer.validate()
            .set_task_instance_id("aerial_survey_polylines")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "get_width": 2.25,
                    "get_color": [255, 265, 0],
                    "opacity": 0.85,
                    "width_units": "pixels",
                    "width_scale": 1,
                    "width_min_pixels": 2,
                    "width_max_pixels": 8,
                    "cap_rounded": True,
                    "joint_rounded": True,
                    "billboard": False,
                    "stroked": True,
                },
                "legend": {
                    "title": "",
                    "values": [{"label": "Aerial lines", "color": "#ffa500"}],
                },
                "geodataframe": DependsOn("survey_lines"),
            }
            | (params_dict.get("aerial_survey_polylines") or {}),
            method="call",
        ),
        "zoom_gdf_extent": Node(
            async_task=view_state_deck_gdf.validate()
            .set_task_instance_id("zoom_gdf_extent")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "pitch": 0,
                "bearing": 0,
                "gdf": DependsOn("load_gdf"),
            }
            | (params_dict.get("zoom_gdf_extent") or {}),
            method="call",
        ),
        "combine_map_layers": Node(
            async_task=combine_deckgl_map_layers.validate()
            .set_task_instance_id("combine_map_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("generate_layers_map"),
                "grouped_layers": DependsOn("aerial_survey_polylines"),
            }
            | (params_dict.get("combine_map_layers") or {}),
            method="call",
        ),
        "draw_aerial_survey_lines_ecomap": Node(
            async_task=draw_map.validate()
            .set_task_instance_id("draw_aerial_survey_lines_ecomap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "static": False,
                "title": None,
                "max_zoom": 10,
                "legend_style": {"placement": "bottom-right"},
                "geo_layers": DependsOn("combine_map_layers"),
                "view_state": DependsOn("zoom_gdf_extent"),
            }
            | (params_dict.get("draw_aerial_survey_lines_ecomap") or {}),
            method="call",
        ),
        "persist_ecomaps": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_ecomaps")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "text": DependsOn("draw_aerial_survey_lines_ecomap"),
                "filename": "aerial_survey.html",
            }
            | (params_dict.get("persist_ecomaps") or {}),
            method="call",
        ),
        "create_aerial_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .set_task_instance_id("create_aerial_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Aerial Survey Lines",
                "data": DependsOn("persist_ecomaps"),
            }
            | (params_dict.get("create_aerial_widgets") or {}),
            method="call",
        ),
        "patrol_dashboard": Node(
            async_task=gather_dashboard.validate()
            .set_task_instance_id("patrol_dashboard")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "details": DependsOn("workflow_details"),
                "widgets": DependsOn("create_aerial_widgets"),
                "time_range": DependsOn("time_range"),
                "groupers": DependsOn("groupers"),
            }
            | (params_dict.get("patrol_dashboard") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
