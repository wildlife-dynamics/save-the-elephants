# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details

# ruff: noqa: E402

"""WARNING: This file is generated in a testing context and should not be used in production.
Lines specific to the testing context are marked with a test tube emoji (ðŸ§ª) to indicate
that they would not be included (or would be different) in the production version of this file.
"""

import json
import os
import warnings  # ðŸ§ª

from ecoscope_workflows_core.graph import DependsOn, DependsOnSequence, Graph, Node
from ecoscope_workflows_core.tasks.config import set_workflow_details
from ecoscope_workflows_core.tasks.filter import set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers
from ecoscope_workflows_core.testing import create_task_magicmock  # ðŸ§ª
from ecoscope_workflows_ext_ecoscope.tasks.results import set_base_maps

download_roi = create_task_magicmock(  # ðŸ§ª
    anchor="ecoscope_workflows_ext_ecoscope.tasks.io",  # ðŸ§ª
    func_name="download_roi",  # ðŸ§ª
)  # ðŸ§ª
from ecoscope_workflows_core.tasks.io import persist_text
from ecoscope_workflows_core.tasks.results import (
    create_map_widget_single_view,
    gather_dashboard,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df
from ecoscope_workflows_ext_ecoscope.tasks.results import (
    create_polyline_layer,
    draw_ecomap,
)
from ecoscope_workflows_ext_ste.tasks import (
    create_view_state_from_gdf,
    generate_survey_lines,
)

from ..params import Params


def main(params: Params):
    warnings.warn("This test script should not be used in production!")  # ðŸ§ª

    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "initialize_workflow_metadata": [],
        "define_time_range": [],
        "configure_grouping_strategy": [],
        "configure_base_maps": [],
        "fetch_roi_layer": [],
        "draw_survey_lines": ["fetch_roi_layer"],
        "persist_aerial_gdf": ["draw_survey_lines"],
        "persist_aerial_geoparquet": ["draw_survey_lines"],
        "aerial_survey_polylines": ["draw_survey_lines"],
        "zoom_view_state": ["draw_survey_lines"],
        "draw_aerial_survey_lines_ecomap": [
            "configure_base_maps",
            "aerial_survey_polylines",
            "zoom_view_state",
        ],
        "persist_ecomaps": ["draw_aerial_survey_lines_ecomap"],
        "create_aerial_widgets": ["persist_ecomaps"],
        "patrol_dashboard": [
            "initialize_workflow_metadata",
            "create_aerial_widgets",
            "define_time_range",
            "configure_grouping_strategy",
        ],
    }

    nodes = {
        "initialize_workflow_metadata": Node(
            async_task=set_workflow_details.validate()
            .handle_errors(task_instance_id="initialize_workflow_metadata")
            .set_executor("lithops"),
            partial=(params_dict.get("initialize_workflow_metadata") or {}),
            method="call",
        ),
        "define_time_range": Node(
            async_task=set_time_range.validate()
            .handle_errors(task_instance_id="define_time_range")
            .set_executor("lithops"),
            partial={
                "time_format": "%d %b %Y %H:%M:%S %Z",
            }
            | (params_dict.get("define_time_range") or {}),
            method="call",
        ),
        "configure_grouping_strategy": Node(
            async_task=set_groupers.validate()
            .handle_errors(task_instance_id="configure_grouping_strategy")
            .set_executor("lithops"),
            partial=(params_dict.get("configure_grouping_strategy") or {}),
            method="call",
        ),
        "configure_base_maps": Node(
            async_task=set_base_maps.validate()
            .handle_errors(task_instance_id="configure_base_maps")
            .set_executor("lithops"),
            partial=(params_dict.get("configure_base_maps") or {}),
            method="call",
        ),
        "fetch_roi_layer": Node(
            async_task=download_roi.validate()
            .handle_errors(task_instance_id="fetch_roi_layer")
            .set_executor("lithops"),
            partial={
                "roi_column": None,
                "roi_name": None,
                "layer_name": None,
            }
            | (params_dict.get("fetch_roi_layer") or {}),
            method="call",
        ),
        "draw_survey_lines": Node(
            async_task=generate_survey_lines.validate()
            .handle_errors(task_instance_id="draw_survey_lines")
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("fetch_roi_layer"),
            }
            | (params_dict.get("draw_survey_lines") or {}),
            method="call",
        ),
        "persist_aerial_gdf": Node(
            async_task=persist_df.validate()
            .handle_errors(task_instance_id="persist_aerial_gdf")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("draw_survey_lines"),
                "filetype": "gpkg",
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_aerial_gdf") or {}),
            method="call",
        ),
        "persist_aerial_geoparquet": Node(
            async_task=persist_df.validate()
            .handle_errors(task_instance_id="persist_aerial_geoparquet")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("draw_survey_lines"),
                "filetype": "geoparquet",
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_aerial_geoparquet") or {}),
            method="call",
        ),
        "aerial_survey_polylines": Node(
            async_task=create_polyline_layer.validate()
            .handle_errors(task_instance_id="aerial_survey_polylines")
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "get_width": 1.5,
                    "get_color": "#2f4f4f",
                    "opacity": 0.85,
                    "width_unit": "pixels",
                },
                "legend": {"labels": ["Aerial survey lines"], "colors": ["#2f4f4f"]},
                "tooltip_columns": [],
                "geodataframe": DependsOn("draw_survey_lines"),
            }
            | (params_dict.get("aerial_survey_polylines") or {}),
            method="call",
        ),
        "zoom_view_state": Node(
            async_task=create_view_state_from_gdf.validate()
            .handle_errors(task_instance_id="zoom_view_state")
            .set_executor("lithops"),
            partial={
                "pitch": 0,
                "bearing": 0,
                "gdf": DependsOn("draw_survey_lines"),
            }
            | (params_dict.get("zoom_view_state") or {}),
            method="call",
        ),
        "draw_aerial_survey_lines_ecomap": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_aerial_survey_lines_ecomap")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "static": False,
                "max_zoom": 12,
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Aerial survey lines",
                },
                "title": None,
                "geo_layers": DependsOn("aerial_survey_polylines"),
                "view_state": DependsOn("zoom_view_state"),
            }
            | (params_dict.get("draw_aerial_survey_lines_ecomap") or {}),
            method="call",
        ),
        "persist_ecomaps": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_ecomaps")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "text": DependsOn("draw_aerial_survey_lines_ecomap"),
            }
            | (params_dict.get("persist_ecomaps") or {}),
            method="call",
        ),
        "create_aerial_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_aerial_widgets")
            .set_executor("lithops"),
            partial={
                "title": "Aerial Survey Lines",
                "data": DependsOn("persist_ecomaps"),
            }
            | (params_dict.get("create_aerial_widgets") or {}),
            method="call",
        ),
        "patrol_dashboard": Node(
            async_task=gather_dashboard.validate()
            .handle_errors(task_instance_id="patrol_dashboard")
            .set_executor("lithops"),
            partial={
                "details": DependsOn("initialize_workflow_metadata"),
                "widgets": DependsOn("create_aerial_widgets"),
                "time_range": DependsOn("define_time_range"),
                "groupers": DependsOn("configure_grouping_strategy"),
            }
            | (params_dict.get("patrol_dashboard") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
