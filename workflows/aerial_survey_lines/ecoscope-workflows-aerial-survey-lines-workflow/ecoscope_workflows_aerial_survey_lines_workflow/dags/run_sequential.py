# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details
import json
import os

from ecoscope_workflows_core.tasks.config import (
    set_workflow_details as set_workflow_details,
)
from ecoscope_workflows_core.tasks.filter import set_time_range as set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers as set_groupers
from ecoscope_workflows_core.tasks.io import persist_text as persist_text
from ecoscope_workflows_core.tasks.results import (
    create_map_widget_single_view as create_map_widget_single_view,
)
from ecoscope_workflows_core.tasks.results import gather_dashboard as gather_dashboard
from ecoscope_workflows_core.tasks.skip import (
    any_dependency_skipped as any_dependency_skipped,
)
from ecoscope_workflows_core.tasks.skip import any_is_empty_df as any_is_empty_df
from ecoscope_workflows_ext_custom.tasks.io import load_df as load_df
from ecoscope_workflows_ext_custom.tasks.results import (
    create_path_layer as create_path_layer,
)
from ecoscope_workflows_ext_custom.tasks.results import draw_map as draw_map
from ecoscope_workflows_ext_custom.tasks.results import (
    set_base_maps_pydeck as set_base_maps_pydeck,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df as persist_df
from ecoscope_workflows_ext_ste.tasks import (
    combine_deckgl_map_layers as combine_deckgl_map_layers,
)
from ecoscope_workflows_ext_ste.tasks import (
    create_deckgl_layer_from_gdf as create_deckgl_layer_from_gdf,
)
from ecoscope_workflows_ext_ste.tasks import draw_survey_lines as draw_survey_lines
from ecoscope_workflows_ext_ste.tasks import get_file_path as get_file_path
from ecoscope_workflows_ext_ste.tasks import get_gdf_geom_type as get_gdf_geom_type
from ecoscope_workflows_ext_ste.tasks import view_state_deck_gdf as view_state_deck_gdf

from ..params import Params


def main(params: Params):
    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    workflow_details = (
        set_workflow_details.validate()
        .set_task_instance_id("workflow_details")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(**(params_dict.get("workflow_details") or {}))
        .call()
    )

    time_range = (
        set_time_range.validate()
        .set_task_instance_id("time_range")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            time_format="%d %b %Y %H:%M:%S %Z",
            timezone={
                "label": "UTC",
                "tzCode": "UTC",
                "name": "UTC",
                "utc_offset": "+00:00",
            },
            since="2026-01-01T00:00:00Z",
            until="2026-02-28T23:59:59Z",
            **(params_dict.get("time_range") or {}),
        )
        .call()
    )

    groupers = (
        set_groupers.validate()
        .set_task_instance_id("groupers")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(**(params_dict.get("groupers") or {}))
        .call()
    )

    configure_base_maps = (
        set_base_maps_pydeck.validate()
        .set_task_instance_id("configure_base_maps")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(**(params_dict.get("configure_base_maps") or {}))
        .call()
    )

    retrieve_file_params = (
        get_file_path.validate()
        .set_task_instance_id("retrieve_file_params")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            output_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            **(params_dict.get("retrieve_file_params") or {}),
        )
        .call()
    )

    load_gdf = (
        load_df.validate()
        .set_task_instance_id("load_gdf")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            file_path=retrieve_file_params,
            layer=None,
            deserialize_json=False,
            **(params_dict.get("load_gdf") or {}),
        )
        .call()
    )

    assign_geom_type = (
        get_gdf_geom_type.validate()
        .set_task_instance_id("assign_geom_type")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(gdf=load_gdf, **(params_dict.get("assign_geom_type") or {}))
        .call()
    )

    generate_layers_map = (
        create_deckgl_layer_from_gdf.validate()
        .set_task_instance_id("generate_layers_map")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            gdf=assign_geom_type,
            style={
                "get_fill_color": [85, 107, 47],
                "get_line_color": [85, 107, 47],
                "opacity": 0.35,
                "stroked": True,
                "get_line_width": 1.55,
            },
            legend={
                "title": "Area of interest",
                "values": [{"label": "AOI", "color": "#556b2f"}],
            },
            **(params_dict.get("generate_layers_map") or {}),
        )
        .call()
    )

    survey_lines = (
        draw_survey_lines.validate()
        .set_task_instance_id("survey_lines")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(gdf=load_gdf, **(params_dict.get("survey_lines") or {}))
        .call()
    )

    persist_aerial_gdf = (
        persist_df.validate()
        .set_task_instance_id("persist_aerial_gdf")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            filetype="gpkg",
            filename="aerial_survey",
            df=survey_lines,
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            **(params_dict.get("persist_aerial_gdf") or {}),
        )
        .call()
    )

    persist_aerial_gpq = (
        persist_df.validate()
        .set_task_instance_id("persist_aerial_gpq")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            filetype="geoparquet",
            filename="aerial_survey",
            df=survey_lines,
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            **(params_dict.get("persist_aerial_gpq") or {}),
        )
        .call()
    )

    aerial_survey_polylines = (
        create_path_layer.validate()
        .set_task_instance_id("aerial_survey_polylines")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            layer_style={
                "get_width": 2.25,
                "get_color": [255, 265, 0],
                "opacity": 0.85,
                "width_units": "pixels",
                "width_scale": 1,
                "width_min_pixels": 2,
                "width_max_pixels": 8,
                "cap_rounded": True,
                "joint_rounded": True,
                "billboard": False,
                "stroked": True,
            },
            legend={
                "title": "Survey Lines",
                "values": [{"label": "Aerial lines", "color": "#ffa500"}],
            },
            geodataframe=survey_lines,
            **(params_dict.get("aerial_survey_polylines") or {}),
        )
        .call()
    )

    zoom_gdf_extent = (
        view_state_deck_gdf.validate()
        .set_task_instance_id("zoom_gdf_extent")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            pitch=0,
            bearing=0,
            gdf=load_gdf,
            **(params_dict.get("zoom_gdf_extent") or {}),
        )
        .call()
    )

    combine_map_layers = (
        combine_deckgl_map_layers.validate()
        .set_task_instance_id("combine_map_layers")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            static_layers=generate_layers_map,
            grouped_layers=aerial_survey_polylines,
            **(params_dict.get("combine_map_layers") or {}),
        )
        .call()
    )

    draw_aerial_survey_lines_ecomap = (
        draw_map.validate()
        .set_task_instance_id("draw_aerial_survey_lines_ecomap")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            tile_layers=configure_base_maps,
            static=False,
            title=None,
            max_zoom=12,
            legend_style={"placement": "bottom-right"},
            geo_layers=combine_map_layers,
            view_state=zoom_gdf_extent,
            **(params_dict.get("draw_aerial_survey_lines_ecomap") or {}),
        )
        .call()
    )

    persist_ecomaps = (
        persist_text.validate()
        .set_task_instance_id("persist_ecomaps")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            text=draw_aerial_survey_lines_ecomap,
            filename="aerial_survey.html",
            **(params_dict.get("persist_ecomaps") or {}),
        )
        .call()
    )

    create_aerial_widgets = (
        create_map_widget_single_view.validate()
        .set_task_instance_id("create_aerial_widgets")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            title="Aerial Survey Lines",
            data=persist_ecomaps,
            **(params_dict.get("create_aerial_widgets") or {}),
        )
        .call()
    )

    patrol_dashboard = (
        gather_dashboard.validate()
        .set_task_instance_id("patrol_dashboard")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            details=workflow_details,
            widgets=create_aerial_widgets,
            time_range=time_range,
            groupers=groupers,
            **(params_dict.get("patrol_dashboard") or {}),
        )
        .call()
    )

    return patrol_dashboard
