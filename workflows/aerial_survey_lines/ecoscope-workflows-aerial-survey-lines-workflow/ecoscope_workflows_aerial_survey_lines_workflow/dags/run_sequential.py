# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details
import json
import os

from ecoscope_workflows_core.tasks.config import (
    set_workflow_details as set_workflow_details,
)
from ecoscope_workflows_core.tasks.filter import set_time_range as set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers as set_groupers
from ecoscope_workflows_core.tasks.io import persist_text as persist_text
from ecoscope_workflows_core.tasks.results import (
    create_map_widget_single_view as create_map_widget_single_view,
)
from ecoscope_workflows_core.tasks.results import gather_dashboard as gather_dashboard
from ecoscope_workflows_core.tasks.skip import (
    any_dependency_skipped as any_dependency_skipped,
)
from ecoscope_workflows_core.tasks.skip import any_is_empty_df as any_is_empty_df
from ecoscope_workflows_ext_custom.tasks.io import load_df as load_df
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df as persist_df
from ecoscope_workflows_ext_ecoscope.tasks.results import (
    create_polyline_layer as create_polyline_layer,
)
from ecoscope_workflows_ext_ecoscope.tasks.results import draw_ecomap as draw_ecomap
from ecoscope_workflows_ext_ecoscope.tasks.results import set_base_maps as set_base_maps
from ecoscope_workflows_ext_ste.tasks import (
    generate_survey_lines as generate_survey_lines,
)
from ecoscope_workflows_ext_ste.tasks import get_file_path as get_file_path

from ..params import Params


def main(params: Params):
    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    workflow_details = (
        set_workflow_details.validate()
        .set_task_instance_id("workflow_details")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(**(params_dict.get("workflow_details") or {}))
        .call()
    )

    time_range = (
        set_time_range.validate()
        .set_task_instance_id("time_range")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            time_format="%d %b %Y %H:%M:%S %Z",
            timezone={
                "label": "UTC",
                "tzCode": "UTC",
                "name": "UTC",
                "utc_offset": "+00:00",
            },
            **(params_dict.get("time_range") or {}),
        )
        .call()
    )

    groupers = (
        set_groupers.validate()
        .set_task_instance_id("groupers")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(**(params_dict.get("groupers") or {}))
        .call()
    )

    configure_base_maps = (
        set_base_maps.validate()
        .set_task_instance_id("configure_base_maps")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(**(params_dict.get("configure_base_maps") or {}))
        .call()
    )

    retrieve_file_params = (
        get_file_path.validate()
        .set_task_instance_id("retrieve_file_params")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            output_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            **(params_dict.get("retrieve_file_params") or {}),
        )
        .call()
    )

    load_gdf = (
        load_df.validate()
        .set_task_instance_id("load_gdf")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            file_path=retrieve_file_params,
            layer=None,
            deserialize_json=False,
            **(params_dict.get("load_gdf") or {}),
        )
        .call()
    )

    draw_survey_lines = (
        generate_survey_lines.validate()
        .set_task_instance_id("draw_survey_lines")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(gdf=load_gdf, **(params_dict.get("draw_survey_lines") or {}))
        .call()
    )

    persist_aerial_gdf = (
        persist_df.validate()
        .set_task_instance_id("persist_aerial_gdf")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            filetype="gpkg",
            filename="aerial_survey",
            df=draw_survey_lines,
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            **(params_dict.get("persist_aerial_gdf") or {}),
        )
        .call()
    )

    persist_aerial_gpq = (
        persist_df.validate()
        .set_task_instance_id("persist_aerial_gpq")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            filetype="geoparquet",
            filename="aerial_survey",
            df=draw_survey_lines,
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            **(params_dict.get("persist_aerial_gpq") or {}),
        )
        .call()
    )

    aerial_survey_polylines = (
        create_polyline_layer.validate()
        .set_task_instance_id("aerial_survey_polylines")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            layer_style={
                "get_width": 1.5,
                "get_color": "#2f4f4f",
                "opacity": 0.85,
                "width_unit": "pixels",
            },
            legend={"labels": ["Aerial survey lines"], "colors": ["#2f4f4f"]},
            tooltip_columns=[],
            geodataframe=draw_survey_lines,
            **(params_dict.get("aerial_survey_polylines") or {}),
        )
        .call()
    )

    draw_aerial_survey_lines_ecomap = (
        draw_ecomap.validate()
        .set_task_instance_id("draw_aerial_survey_lines_ecomap")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            tile_layers=configure_base_maps,
            static=False,
            max_zoom=12,
            north_arrow_style={"placement": "top-left"},
            legend_style={"placement": "bottom-right", "title": "Aerial survey lines"},
            title=None,
            geo_layers=aerial_survey_polylines,
            view_state=None,
            **(params_dict.get("draw_aerial_survey_lines_ecomap") or {}),
        )
        .call()
    )

    persist_ecomaps = (
        persist_text.validate()
        .set_task_instance_id("persist_ecomaps")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            text=draw_aerial_survey_lines_ecomap,
            filename="aerial_survey.html",
            **(params_dict.get("persist_ecomaps") or {}),
        )
        .call()
    )

    create_aerial_widgets = (
        create_map_widget_single_view.validate()
        .set_task_instance_id("create_aerial_widgets")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            title="Aerial Survey Lines",
            data=persist_ecomaps,
            **(params_dict.get("create_aerial_widgets") or {}),
        )
        .call()
    )

    patrol_dashboard = (
        gather_dashboard.validate()
        .set_task_instance_id("patrol_dashboard")
        .handle_errors()
        .with_tracing()
        .skipif(
            conditions=[
                any_is_empty_df,
                any_dependency_skipped,
            ],
            unpack_depth=1,
        )
        .partial(
            details=workflow_details,
            widgets=create_aerial_widgets,
            time_range=time_range,
            groupers=groupers,
            **(params_dict.get("patrol_dashboard") or {}),
        )
        .call()
    )

    return patrol_dashboard
