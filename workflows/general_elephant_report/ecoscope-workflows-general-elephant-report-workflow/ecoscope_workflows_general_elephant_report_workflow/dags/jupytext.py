# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details


# ruff: noqa: E402

# %% [markdown]
# # General Elephant Report
# TODO: top level description

# %% [markdown]
# ## Imports

import os
from ecoscope_workflows_core.tasks.config import set_workflow_details
from ecoscope_workflows_core.tasks.filter import set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers
from ecoscope_workflows_ext_ecoscope.tasks.results import set_base_maps
from ecoscope_workflows_ext_ste.tasks import create_directory
from ecoscope_workflows_ext_ste.tasks import download_land_dx
from ecoscope_workflows_ext_ste.tasks import load_landdx_aoi
from ecoscope_workflows_ext_ste.tasks import split_gdf_by_column
from ecoscope_workflows_ext_ste.tasks import annotate_gdf_dict_with_geometry_type
from ecoscope_workflows_ext_ste.tasks import create_map_layers_from_annotated_dict
from ecoscope_workflows_core.tasks.io import set_er_connection
from ecoscope_workflows_core.tasks.io import set_gee_connection
from ecoscope_workflows_ext_ecoscope.tasks.io import get_subjectgroup_observations
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import process_relocations
from ecoscope_workflows_ext_ecoscope.tasks.transformation import classify_is_night
from ecoscope_workflows_ext_ste.tasks import add_day_night_column
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import (
    relocations_to_trajectory,
)
from ecoscope_workflows_core.tasks.transformation import add_temporal_index
from ecoscope_workflows_ext_ecoscope.tasks.transformation import apply_classification
from ecoscope_workflows_ext_ecoscope.tasks.analysis import (
    calculate_elliptical_time_density,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import determine_season_windows
from ecoscope_workflows_ext_ste.tasks import create_seasonal_labels
from ecoscope_workflows_ext_ste.tasks import convert_col_to_rgba
from ecoscope_workflows_ext_ecoscope.tasks.analysis import create_meshgrid
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df
from ecoscope_workflows_ext_ste.tasks import assign_column
from ecoscope_workflows_ext_ste.tasks import spatial_join
from ecoscope_workflows_ext_ste.tasks import assign_value_by_index
from ecoscope_workflows_core.tasks.groupby import split_groups
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polyline_layer
from ecoscope_workflows_core.tasks.skip import any_is_empty_df
from ecoscope_workflows_core.tasks.skip import any_dependency_skipped
from ecoscope_workflows_ext_ste.tasks import combine_map_layers
from ecoscope_workflows_ext_ste.tasks import create_view_state_from_gdf
from ecoscope_workflows_ext_ste.tasks import zip_grouped_by_key
from ecoscope_workflows_ext_ecoscope.tasks.results import draw_ecomap
from ecoscope_workflows_core.tasks.io import persist_text
from ecoscope_workflows_core.tasks.results import create_map_widget_single_view
from ecoscope_workflows_core.tasks.skip import never
from ecoscope_workflows_core.tasks.results import merge_widget_views
from ecoscope_workflows_ext_ecoscope.tasks.transformation import apply_color_map
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polygon_layer
from ecoscope_workflows_ext_ste.tasks import filter_column_values
from ecoscope_workflows_ext_ste.tasks import calculate_etd_by_groups
from ecoscope_workflows_core.tasks.transformation import sort_values
from ecoscope_workflows_ext_ste.tasks import compute_fix_density_and_night_class
from ecoscope_workflows_ext_ste.tasks import filter_time_dominance
from ecoscope_workflows_ext_ecoscope.tasks.transformation import (
    drop_nan_values_by_column,
)
from ecoscope_workflows_ext_ste.tasks import drop_missing_values_by_column
from ecoscope_workflows_ext_ste.tasks import generate_ecograph_raster
from ecoscope_workflows_ext_ste.tasks import retrieve_feature_gdf
from ecoscope_workflows_core.tasks.transformation import map_values_with_unit
from ecoscope_workflows_ext_ste.tasks import category_summary
from ecoscope_workflows_ext_ste.tasks import plot_protected_fix_proportions
from ecoscope_workflows_core.tasks.results import create_plot_widget_single_view
from ecoscope_workflows_core.tasks.results import gather_dashboard

# %% [markdown]
# ## Initialize workflow metadata

# %%
# parameters

initialize_workflow_metadata_params = dict(
    name=...,
    description=...,
    image_url=...,
)

# %%
# call the task


initialize_workflow_metadata = (
    set_workflow_details.handle_errors(task_instance_id="initialize_workflow_metadata")
    .partial(**initialize_workflow_metadata_params)
    .call()
)


# %% [markdown]
# ## Define time range

# %%
# parameters

define_time_range_params = dict(
    since=...,
    until=...,
)

# %%
# call the task


define_time_range = (
    set_time_range.handle_errors(task_instance_id="define_time_range")
    .partial(time_format="%d %b %Y %H:%M:%S %Z", **define_time_range_params)
    .call()
)


# %% [markdown]
# ## Configure grouping strategy

# %%
# parameters

configure_grouping_strategy_params = dict(
    groupers=...,
)

# %%
# call the task


configure_grouping_strategy = (
    set_groupers.handle_errors(task_instance_id="configure_grouping_strategy")
    .partial(**configure_grouping_strategy_params)
    .call()
)


# %% [markdown]
# ## Configure base map layers

# %%
# parameters

configure_base_maps_params = dict(
    base_maps=...,
)

# %%
# call the task


configure_base_maps = (
    set_base_maps.handle_errors(task_instance_id="configure_base_maps")
    .partial(**configure_base_maps_params)
    .call()
)


# %% [markdown]
# ## Create output directory

# %%
# parameters

create_output_directory_params = dict(
    path_name=...,
)

# %%
# call the task


create_output_directory = (
    create_directory.handle_errors(task_instance_id="create_output_directory")
    .partial(**create_output_directory_params)
    .call()
)


# %% [markdown]
# ## Retrieve and Unpack LandDx db

# %%
# parameters

retrieve_landdx_database_params = dict(
    url=...,
    overwrite_existing=...,
    unzip=...,
)

# %%
# call the task


retrieve_landdx_database = (
    download_land_dx.handle_errors(task_instance_id="retrieve_landdx_database")
    .partial(path=create_output_directory, **retrieve_landdx_database_params)
    .call()
)


# %% [markdown]
# ## Filter area of interest from LandDx db

# %%
# parameters

load_aoi_params = dict(
    aoi=...,
)

# %%
# call the task


load_aoi = (
    load_landdx_aoi.handle_errors(task_instance_id="load_aoi")
    .partial(map_path=retrieve_landdx_database, **load_aoi_params)
    .call()
)


# %% [markdown]
# ## Split LandDx Layers by Type

# %%
# parameters

split_landdx_by_type_params = dict()

# %%
# call the task


split_landdx_by_type = (
    split_gdf_by_column.handle_errors(task_instance_id="split_landdx_by_type")
    .partial(gdf=load_aoi, column="type", **split_landdx_by_type_params)
    .call()
)


# %% [markdown]
# ## Annotate LandDx Geometry Types

# %%
# parameters

annotate_geometry_types_params = dict()

# %%
# call the task


annotate_geometry_types = (
    annotate_gdf_dict_with_geometry_type.handle_errors(
        task_instance_id="annotate_geometry_types"
    )
    .partial(gdf_dict=split_landdx_by_type, **annotate_geometry_types_params)
    .call()
)


# %% [markdown]
# ## Style LandDx Map Layers

# %%
# parameters

create_styled_landdx_layers_params = dict(
    style_config=...,
)

# %%
# call the task


create_styled_landdx_layers = (
    create_map_layers_from_annotated_dict.handle_errors(
        task_instance_id="create_styled_landdx_layers"
    )
    .partial(
        annotated_dict=annotate_geometry_types, **create_styled_landdx_layers_params
    )
    .call()
)


# %% [markdown]
# ## Connect to EarthRanger

# %%
# parameters

er_client_name_params = dict(
    data_source=...,
)

# %%
# call the task


er_client_name = (
    set_er_connection.handle_errors(task_instance_id="er_client_name")
    .partial(**er_client_name_params)
    .call()
)


# %% [markdown]
# ## Connect to EE

# %%
# parameters

gee_project_name_params = dict(
    data_source=...,
)

# %%
# call the task


gee_project_name = (
    set_gee_connection.handle_errors(task_instance_id="gee_project_name")
    .partial(**gee_project_name_params)
    .call()
)


# %% [markdown]
# ## Get subject Group Observations from ER

# %%
# parameters

subject_observations_params = dict(
    subject_group_name=...,
)

# %%
# call the task


subject_observations = (
    get_subjectgroup_observations.handle_errors(task_instance_id="subject_observations")
    .partial(
        client=er_client_name,
        time_range=define_time_range,
        raise_on_empty=False,
        include_details=False,
        include_subjectsource_details=False,
        **subject_observations_params,
    )
    .call()
)


# %% [markdown]
# ## Transform Observations to Relocations

# %%
# parameters

subject_reloc_params = dict()

# %%
# call the task


subject_reloc = (
    process_relocations.handle_errors(task_instance_id="subject_reloc")
    .partial(
        observations=subject_observations,
        relocs_columns=[
            "fixtime",
            "geometry",
            "groupby_col",
            "junk_status",
            "extra__created_at",
            "extra__subject__sex",
            "extra__subject__hex",
            "extra__subject__name",
            "extra__subject__subject_subtype",
        ],
        filter_point_coords=[
            {"x": 180.0, "y": 90.0},
            {"x": 0.0, "y": 0.0},
            {"x": 1.0, "y": 1.0},
        ],
        **subject_reloc_params,
    )
    .call()
)


# %% [markdown]
# ## Annotate Relocations with Day/Night Labels

# %%
# parameters

annotate_day_night_params = dict()

# %%
# call the task


annotate_day_night = (
    classify_is_night.handle_errors(task_instance_id="annotate_day_night")
    .partial(relocations=subject_reloc, **annotate_day_night_params)
    .call()
)


# %% [markdown]
# ## Label day-night columns

# %%
# parameters

day_night_column_params = dict(
    new_col=...,
)

# %%
# call the task


day_night_column = (
    add_day_night_column.handle_errors(task_instance_id="day_night_column")
    .partial(source_col="is_night", df=annotate_day_night, **day_night_column_params)
    .call()
)


# %% [markdown]
# ## Convert Relocations to Trajectories

# %%
# parameters

convert_to_trajectories_params = dict(
    trajectory_segment_filter=...,
)

# %%
# call the task


convert_to_trajectories = (
    relocations_to_trajectory.handle_errors(task_instance_id="convert_to_trajectories")
    .partial(relocations=day_night_column, **convert_to_trajectories_params)
    .call()
)


# %% [markdown]
# ## Add Temporal Index to Trajectories

# %%
# parameters

add_temporal_index_to_traj_params = dict()

# %%
# call the task


add_temporal_index_to_traj = (
    add_temporal_index.handle_errors(task_instance_id="add_temporal_index_to_traj")
    .partial(
        df=convert_to_trajectories,
        time_col="segment_start",
        groupers=configure_grouping_strategy,
        cast_to_datetime=True,
        format="mixed",
        **add_temporal_index_to_traj_params,
    )
    .call()
)


# %% [markdown]
# ## Classify Trajectories by Speed

# %%
# parameters

classify_trajectory_speed_bins_params = dict()

# %%
# call the task


classify_trajectory_speed_bins = (
    apply_classification.handle_errors(
        task_instance_id="classify_trajectory_speed_bins"
    )
    .partial(
        df=add_temporal_index_to_traj,
        input_column_name="speed_kmhr",
        output_column_name="speed_bins",
        classification_options={"scheme": "equal_interval", "k": 6},
        label_options={"label_ranges": False, "label_decimals": 1},
        **classify_trajectory_speed_bins_params,
    )
    .call()
)


# %% [markdown]
# ## Generate Seasonal Home Range ETD

# %%
# parameters

generate_seasonal_etd_params = dict(
    auto_scale_or_custom_cell_size=...,
    max_speed_factor=...,
    expansion_factor=...,
)

# %%
# call the task


generate_seasonal_etd = (
    calculate_elliptical_time_density.handle_errors(
        task_instance_id="generate_seasonal_etd"
    )
    .partial(
        crs="ESRI:53042",
        percentiles=[50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
        nodata_value="nan",
        band_count=1,
        trajectory_gdf=classify_trajectory_speed_bins,
        **generate_seasonal_etd_params,
    )
    .call()
)


# %% [markdown]
# ## Determine Seasonal Windows

# %%
# parameters

determine_seasonal_windows_params = dict()

# %%
# call the task


determine_seasonal_windows = (
    determine_season_windows.handle_errors(
        task_instance_id="determine_seasonal_windows"
    )
    .partial(
        client=gee_project_name,
        roi=generate_seasonal_etd,
        time_range=define_time_range,
        **determine_seasonal_windows_params,
    )
    .call()
)


# %% [markdown]
# ## Generate Seasonal labels

# %%
# parameters

add_season_labels_params = dict()

# %%
# call the task


add_season_labels = (
    create_seasonal_labels.handle_errors(task_instance_id="add_season_labels")
    .partial(
        traj=classify_trajectory_speed_bins,
        total_percentiles=determine_seasonal_windows,
        **add_season_labels_params,
    )
    .call()
)


# %% [markdown]
# ## Convert subject hex colors to rgba

# %%
# parameters

convert_hex_rgba_params = dict()

# %%
# call the task


convert_hex_rgba = (
    convert_col_to_rgba.handle_errors(task_instance_id="convert_hex_rgba")
    .partial(
        df=add_season_labels,
        col="extra__hex",
        new_col="hex_colors",
        **convert_hex_rgba_params,
    )
    .call()
)


# %% [markdown]
# ## Create day night meshgrid

# %%
# parameters

create_dn_meshgrid_params = dict(
    auto_scale_or_custom_cell_size=...,
)

# %%
# call the task


create_dn_meshgrid = (
    create_meshgrid.handle_errors(task_instance_id="create_dn_meshgrid")
    .partial(
        intersecting_only=False,
        crs="EPSG:3857",
        aoi=day_night_column,
        **create_dn_meshgrid_params,
    )
    .call()
)


# %% [markdown]
# ## Persist trajectories as gpkg

# %%
# parameters

persist_traj_df_params = dict(
    filename=...,
)

# %%
# call the task


persist_traj_df = (
    persist_df.handle_errors(task_instance_id="persist_traj_df")
    .partial(
        df=convert_hex_rgba,
        filetype="gpkg",
        root_path=create_output_directory,
        **persist_traj_df_params,
    )
    .call()
)


# %% [markdown]
# ## Persist Relocations as gpkg

# %%
# parameters

persist_relocs_df_params = dict(
    filename=...,
)

# %%
# call the task


persist_relocs_df = (
    persist_df.handle_errors(task_instance_id="persist_relocs_df")
    .partial(
        df=day_night_column,
        filetype="gpkg",
        root_path=create_output_directory,
        **persist_relocs_df_params,
    )
    .call()
)


# %% [markdown]
# ## Assign column to trajs

# %%
# parameters

assign_cols_params = dict()

# %%
# call the task


assign_cols = (
    assign_column.handle_errors(task_instance_id="assign_cols")
    .partial(
        column_name="area_status",
        value="unprotected",
        df=convert_hex_rgba,
        **assign_cols_params,
    )
    .call()
)


# %% [markdown]
# ## Join protected areas and trajectories

# %%
# parameters

join_traj_landdx_params = dict(
    distance=...,
)

# %%
# call the task


join_traj_landdx = (
    spatial_join.handle_errors(task_instance_id="join_traj_landdx")
    .partial(
        how="inner",
        predicate="intersects",
        local_gdf=load_aoi,
        trajs_gdf=assign_cols,
        **join_traj_landdx_params,
    )
    .call()
)


# %% [markdown]
# ## Assign value by index

# %%
# parameters

assign_protected_values_params = dict(
    create_if_missing=...,
)

# %%
# call the task


assign_protected_values = (
    assign_value_by_index.handle_errors(task_instance_id="assign_protected_values")
    .partial(
        df=assign_cols,
        subset_df=join_traj_landdx,
        column_name="area_status",
        value="protected",
        **assign_protected_values_params,
    )
    .call()
)


# %% [markdown]
# ## Split Trajectories by Group

# %%
# parameters

split_trajectories_by_group_params = dict()

# %%
# call the task


split_trajectories_by_group = (
    split_groups.handle_errors(task_instance_id="split_trajectories_by_group")
    .partial(
        df=assign_protected_values,
        groupers=configure_grouping_strategy,
        **split_trajectories_by_group_params,
    )
    .call()
)


# %% [markdown]
# ## Split Relocations by Group

# %%
# parameters

split_relocations_by_group_params = dict()

# %%
# call the task


split_relocations_by_group = (
    split_groups.handle_errors(task_instance_id="split_relocations_by_group")
    .partial(
        df=day_night_column,
        groupers=configure_grouping_strategy,
        **split_relocations_by_group_params,
    )
    .call()
)


# %% [markdown]
# ## Create subject tracks

# %%
# parameters

generate_substyled_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_substyled_layers = (
    create_polyline_layer.handle_errors(task_instance_id="generate_substyled_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "color_column": "hex_colors",
            "auto_highlight": True,
            "pickable": True,
            "get_width": 3.0,
            "width_unit": "pixels",
            "cap_rounded": True,
            "opacity": 0.25,
        },
        legend={"label_column": "extra__name", "color_column": "extra__hex"},
        tooltip_columns=["extra__hex", "extra__name", "extra__sex"],
        **generate_substyled_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Combine LandDx and track layers

# %%
# parameters

combine_substyled_layers_params = dict()

# %%
# call the task


combine_substyled_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_substyled_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_substyled_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_substyled_layers)
)


# %% [markdown]
# ## Zoom by view state

# %%
# parameters

zoom_traj_view_params = dict()

# %%
# call the task


zoom_traj_view = (
    create_view_state_from_gdf.handle_errors(task_instance_id="zoom_traj_view")
    .partial(pitch=0, bearing=0, **zoom_traj_view_params)
    .mapvalues(argnames=["gdf"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

substyled_view_zip_params = dict()

# %%
# call the task


substyled_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="substyled_view_zip")
    .partial(
        left=combine_substyled_layers, right=zoom_traj_view, **substyled_view_zip_params
    )
    .call()
)


# %% [markdown]
# ## Draw subject-styled ecomaps

# %%
# parameters

draw_substyled_ecomaps_params = dict()

# %%
# call the task


draw_substyled_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_substyled_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Subject Tracks"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_substyled_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=substyled_view_zip)
)


# %% [markdown]
# ## Persist track ecomaps

# %%
# parameters

persist_substyled_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_substyled_urls = (
    persist_text.handle_errors(task_instance_id="persist_substyled_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_substyled_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_substyled_ecomaps)
)


# %% [markdown]
# ## Create track ecomap widgets

# %%
# parameters

create_substyled_ecomap_widgets_params = dict()

# %%
# call the task


create_substyled_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_substyled_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Subject Tracks Ecomaps", **create_substyled_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_substyled_urls)
)


# %% [markdown]
# ## Merge track widgets

# %%
# parameters

merge_substyled_widgets_params = dict()

# %%
# call the task


merge_substyled_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_substyled_widgets")
    .partial(widgets=create_substyled_ecomap_widgets, **merge_substyled_widgets_params)
    .call()
)


# %% [markdown]
# ## Generate home range

# %%
# parameters

generate_etd_params = dict(
    auto_scale_or_custom_cell_size=...,
    max_speed_factor=...,
    expansion_factor=...,
)

# %%
# call the task


generate_etd = (
    calculate_elliptical_time_density.handle_errors(task_instance_id="generate_etd")
    .partial(
        crs="ESRI:53042",
        percentiles=[50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
        nodata_value="nan",
        band_count=1,
        **generate_etd_params,
    )
    .mapvalues(argnames=["trajectory_gdf"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Time density colormap

# %%
# parameters

td_colormap_params = dict()

# %%
# call the task


td_colormap = (
    apply_color_map.handle_errors(task_instance_id="td_colormap")
    .partial(
        input_column_name="percentile",
        colormap="RdYlGn",
        output_column_name="percentile_colormap",
        **td_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=generate_etd)
)


# %% [markdown]
# ## Create hr layers

# %%
# parameters

generate_etd_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_etd_ecomap_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_etd_ecomap_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "percentile_colormap",
            "opacity": 0.25,
            "stroked": False,
        },
        legend={"label_column": "percentile", "color_column": "percentile_colormap"},
        tooltip_columns=["percentile"],
        **generate_etd_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=td_colormap)
)


# %% [markdown]
# ## Combine LandDx and hr layer

# %%
# parameters

combine_landdx_hr_ecomap_layers_params = dict()

# %%
# call the task


combine_landdx_hr_ecomap_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_landdx_hr_ecomap_layers")
    .partial(
        static_layers=create_styled_landdx_layers,
        **combine_landdx_hr_ecomap_layers_params,
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_etd_ecomap_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

hr_view_zip_params = dict()

# %%
# call the task


hr_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="hr_view_zip")
    .partial(
        left=combine_landdx_hr_ecomap_layers, right=zoom_traj_view, **hr_view_zip_params
    )
    .call()
)


# %% [markdown]
# ## Draw home range ecomap

# %%
# parameters

draw_hr_ecomaps_params = dict()

# %%
# call the task


draw_hr_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_hr_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Home Range Metrics"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_hr_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=hr_view_zip)
)


# %% [markdown]
# ## Persist home range ecomap

# %%
# parameters

persist_hr_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_hr_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_hr_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_hr_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_hr_ecomaps)
)


# %% [markdown]
# ## Create home range ecomap widgets

# %%
# parameters

create_hr_ecomap_widgets_params = dict()

# %%
# call the task


create_hr_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_hr_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Home Range Ecomap", **create_hr_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_hr_ecomap_urls)
)


# %% [markdown]
# ## Merge home range ecomap widgets

# %%
# parameters

merge_hr_ecomap_widgets_params = dict()

# %%
# call the task


merge_hr_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_hr_ecomap_widgets")
    .partial(widgets=create_hr_ecomap_widgets, **merge_hr_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Filter out 99th percentile

# %%
# parameters

custom_hr_params = dict(
    include=...,
)

# %%
# call the task


custom_hr = (
    filter_column_values.handle_errors(task_instance_id="custom_hr")
    .partial(column="percentile", values=[99.0], **custom_hr_params)
    .mapvalues(argnames=["df"], argvalues=generate_etd)
)


# %% [markdown]
# ## 99th percentile time density colormap

# %%
# parameters

custom_td_colormap_params = dict()

# %%
# call the task


custom_td_colormap = (
    apply_color_map.handle_errors(task_instance_id="custom_td_colormap")
    .partial(
        input_column_name="percentile",
        colormap=["#d2691e"],
        output_column_name="percentile_colormap",
        **custom_td_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=custom_hr)
)


# %% [markdown]
# ## Create 99th hr ecomap layers

# %%
# parameters

generate_cetd_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_cetd_ecomap_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_cetd_ecomap_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "percentile_colormap",
            "opacity": 0.25,
            "stroked": False,
        },
        legend={"label_column": "percentile", "color_column": "percentile_colormap"},
        tooltip_columns=["percentile"],
        **generate_cetd_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=custom_td_colormap)
)


# %% [markdown]
# ## Combine LandDx and Custom HR ecomap layers

# %%
# parameters

combine_landdx_custom_hr_layers_params = dict()

# %%
# call the task


combine_landdx_custom_hr_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_landdx_custom_hr_layers")
    .partial(
        static_layers=create_styled_landdx_layers,
        **combine_landdx_custom_hr_layers_params,
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_cetd_ecomap_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

custom_hr_view_zip_params = dict()

# %%
# call the task


custom_hr_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="custom_hr_view_zip")
    .partial(
        left=combine_landdx_custom_hr_layers,
        right=zoom_traj_view,
        **custom_hr_view_zip_params,
    )
    .call()
)


# %% [markdown]
# ## Draw 99th percentile hr ecomap

# %%
# parameters

draw_custom_hr_ecomaps_params = dict()

# %%
# call the task


draw_custom_hr_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_custom_hr_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Home Range Metrics"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_custom_hr_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=custom_hr_view_zip)
)


# %% [markdown]
# ## Persist custom hr ecomap

# %%
# parameters

persist_custom_hr_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_custom_hr_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_custom_hr_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_custom_hr_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_custom_hr_ecomaps)
)


# %% [markdown]
# ## Create custom hr ecomap widgets

# %%
# parameters

create_custom_hr_ecomap_widgets_params = dict()

# %%
# call the task


create_custom_hr_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_custom_hr_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(
        title="99th Percentile Home Range Ecomap",
        **create_custom_hr_ecomap_widgets_params,
    )
    .map(argnames=["view", "data"], argvalues=persist_custom_hr_ecomap_urls)
)


# %% [markdown]
# ## Merge Custom HR Ecomap widgets

# %%
# parameters

merge_custom_hr_ecomap_widgets_params = dict()

# %%
# call the task


merge_custom_hr_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_custom_hr_ecomap_widgets")
    .partial(
        widgets=create_custom_hr_ecomap_widgets, **merge_custom_hr_ecomap_widgets_params
    )
    .call()
)


# %% [markdown]
# ## Generate seasonal etd

# %%
# parameters

generate_season_etd_params = dict(
    auto_scale_or_custom_cell_size=...,
    max_speed_factor=...,
    expansion_factor=...,
)

# %%
# call the task


generate_season_etd = (
    calculate_etd_by_groups.handle_errors(task_instance_id="generate_season_etd")
    .partial(
        crs="ESRI:53042",
        percentiles=[50.0, 60.0, 70.0, 80.0, 90.0, 99.0],
        nodata_value="nan",
        band_count=1,
        include_groups=True,
        groupby_cols=["season"],
        **generate_season_etd_params,
    )
    .mapvalues(argnames=["trajectory_gdf"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Sort values by seasons values

# %%
# parameters

sort_season_etd_color_params = dict()

# %%
# call the task


sort_season_etd_color = (
    sort_values.handle_errors(task_instance_id="sort_season_etd_color")
    .partial(
        column_name="season",
        ascending=False,
        na_position="last",
        **sort_season_etd_color_params,
    )
    .mapvalues(argnames=["df"], argvalues=generate_season_etd)
)


# %% [markdown]
# ## Apply colormap to season hr

# %%
# parameters

apply_season_etd_colormap_params = dict()

# %%
# call the task


apply_season_etd_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_season_etd_colormap")
    .partial(
        input_column_name="season",
        colormap=["#483d8b", "#deb887"],
        output_column_name="season_colormap",
        **apply_season_etd_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_season_etd_color)
)


# %% [markdown]
# ## Create season ecomap layers

# %%
# parameters

generate_season_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_season_ecomap_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_season_ecomap_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "season_colormap",
            "opacity": 0.25,
            "stroked": False,
        },
        legend={"label_column": "season", "color_column": "season_colormap"},
        tooltip_columns=["season"],
        **generate_season_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=apply_season_etd_colormap)
)


# %% [markdown]
# ## Combine LandDx and season ecomap layers

# %%
# parameters

combine_landdx_season_layers_params = dict()

# %%
# call the task


combine_landdx_season_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_landdx_season_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_landdx_season_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_season_ecomap_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

season_view_zip_params = dict()

# %%
# call the task


season_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="season_view_zip")
    .partial(
        left=combine_landdx_season_layers,
        right=zoom_traj_view,
        **season_view_zip_params,
    )
    .call()
)


# %% [markdown]
# ## Draw season hr ecomap

# %%
# parameters

draw_season_ecomaps_params = dict()

# %%
# call the task


draw_season_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_season_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Seasons"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_season_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=season_view_zip)
)


# %% [markdown]
# ## Persist season ecomap html paths

# %%
# parameters

persist_season_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_season_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_season_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_season_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_season_ecomaps)
)


# %% [markdown]
# ## Create season ecomap widgets

# %%
# parameters

create_season_ecomap_widgets_params = dict()

# %%
# call the task


create_season_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_season_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Seasonal Ecomap", **create_season_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_season_ecomap_urls)
)


# %% [markdown]
# ## Merge Season Ecomap widgets

# %%
# parameters

merge_season_ecomap_widgets_params = dict()

# %%
# call the task


merge_season_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_season_ecomap_widgets")
    .partial(widgets=create_season_ecomap_widgets, **merge_season_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Compute day-night fixes

# %%
# parameters

time_dominance_params = dict(
    threshold=...,
)

# %%
# call the task


time_dominance = (
    compute_fix_density_and_night_class.handle_errors(task_instance_id="time_dominance")
    .partial(
        mode="dominance",
        grid=create_dn_meshgrid,
        geometry_type="point",
        **time_dominance_params,
    )
    .mapvalues(argnames=["selection"], argvalues=split_relocations_by_group)
)


# %% [markdown]
# ## relevant time dominance values

# %%
# parameters

filter_dominance_values_params = dict()

# %%
# call the task


filter_dominance_values = (
    filter_time_dominance.handle_errors(task_instance_id="filter_dominance_values")
    .partial(valid_dominance=["day", "night"], **filter_dominance_values_params)
    .mapvalues(argnames=["df"], argvalues=time_dominance)
)


# %% [markdown]
# ## sort values by day-night

# %%
# parameters

sort_dominance_values_params = dict()

# %%
# call the task


sort_dominance_values = (
    sort_values.handle_errors(task_instance_id="sort_dominance_values")
    .partial(
        column_name="time_dominance",
        ascending=False,
        na_position="last",
        **sort_dominance_values_params,
    )
    .mapvalues(argnames=["df"], argvalues=filter_dominance_values)
)


# %% [markdown]
# ## Apply colormap to day-night dominance

# %%
# parameters

apply_dn_dom_colormap_params = dict()

# %%
# call the task


apply_dn_dom_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_dn_dom_colormap")
    .partial(
        input_column_name="time_dominance",
        colormap=["#a52a2a", "#ffd700"],
        output_column_name="time_dominance_colormap",
        **apply_dn_dom_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_dominance_values)
)


# %% [markdown]
# ## Create time dominance ecomap layers

# %%
# parameters

generate_td_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_td_ecomap_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_td_ecomap_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "time_dominance_colormap",
            "opacity": 0.25,
            "stroked": True,
        },
        legend={
            "label_column": "time_dominance",
            "color_column": "time_dominance_colormap",
        },
        tooltip_columns=["density", "time_dominance"],
        **generate_td_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=apply_dn_dom_colormap)
)


# %% [markdown]
# ## Combine LandDx and day/night ecomaps

# %%
# parameters

combine_landdx_td_layers_params = dict()

# %%
# call the task


combine_landdx_td_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_landdx_td_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_landdx_td_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_td_ecomap_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

td_view_zip_params = dict()

# %%
# call the task


td_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="td_view_zip")
    .partial(left=combine_landdx_td_layers, right=zoom_traj_view, **td_view_zip_params)
    .call()
)


# %% [markdown]
# ## Draw time dominance ecomap

# %%
# parameters

draw_tdominance_ecomaps_params = dict()

# %%
# call the task


draw_tdominance_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_tdominance_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Time of Day Dominance"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_tdominance_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=td_view_zip)
)


# %% [markdown]
# ## Persist time dominance ecomap html paths

# %%
# parameters

persist_tdominance_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_tdominance_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_tdominance_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_tdominance_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_tdominance_ecomaps)
)


# %% [markdown]
# ## Create time dominance Ecomap widgets

# %%
# parameters

create_tdom_ecomap_widgets_params = dict()

# %%
# call the task


create_tdom_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_tdom_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Day/Night Ecomap", **create_tdom_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_tdominance_ecomap_urls)
)


# %% [markdown]
# ## Merge time dominance Ecomap widgets

# %%
# parameters

merge_td_ecomap_widgets_params = dict()

# %%
# call the task


merge_td_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_td_ecomap_widgets")
    .partial(widgets=create_tdom_ecomap_widgets, **merge_td_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Compute night proportion fixes

# %%
# parameters

night_proportion_fixes_params = dict()

# %%
# call the task


night_proportion_fixes = (
    compute_fix_density_and_night_class.handle_errors(
        task_instance_id="night_proportion_fixes"
    )
    .partial(
        mode="proportion",
        grid=create_dn_meshgrid,
        geometry_type="point",
        threshold=0.65,
        **night_proportion_fixes_params,
    )
    .mapvalues(argnames=["selection"], argvalues=split_relocations_by_group)
)


# %% [markdown]
# ## sort night proportion values

# %%
# parameters

sort_night_proportion_values_params = dict()

# %%
# call the task


sort_night_proportion_values = (
    sort_values.handle_errors(task_instance_id="sort_night_proportion_values")
    .partial(
        column_name="night_class",
        ascending=False,
        na_position="last",
        **sort_night_proportion_values_params,
    )
    .mapvalues(argnames=["df"], argvalues=night_proportion_fixes)
)


# %% [markdown]
# ## Drop nan values

# %%
# parameters

drop_nan_proportion_values_params = dict()

# %%
# call the task


drop_nan_proportion_values = (
    drop_nan_values_by_column.handle_errors(
        task_instance_id="drop_nan_proportion_values"
    )
    .partial(column_name="density", **drop_nan_proportion_values_params)
    .mapvalues(argnames=["df"], argvalues=sort_night_proportion_values)
)


# %% [markdown]
# ## Drop nan threshold values

# %%
# parameters

drop_nan_threshold_values_params = dict()

# %%
# call the task


drop_nan_threshold_values = (
    drop_missing_values_by_column.handle_errors(
        task_instance_id="drop_nan_threshold_values"
    )
    .partial(column_name="night_class", **drop_nan_threshold_values_params)
    .mapvalues(argnames=["df"], argvalues=drop_nan_proportion_values)
)


# %% [markdown]
# ## Apply colormap to nightime dominance

# %%
# parameters

apply_nightpr_colormap_params = dict()

# %%
# call the task


apply_nightpr_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_nightpr_colormap")
    .partial(
        input_column_name="night_class",
        colormap=["#6495ed", "#00008b"],
        output_column_name="night_class_colormap",
        **apply_nightpr_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=drop_nan_threshold_values)
)


# %% [markdown]
# ## Create night-time proportion ecomap layers

# %%
# parameters

generate_nightpr_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_nightpr_ecomap_layers = (
    create_polygon_layer.handle_errors(
        task_instance_id="generate_nightpr_ecomap_layers"
    )
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "night_class_colormap",
            "opacity": 0.25,
            "stroked": True,
        },
        legend={"label_column": "night_class", "color_column": "night_class_colormap"},
        tooltip_columns=["density", "night_class", "night_class_colormap"],
        **generate_nightpr_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=apply_nightpr_colormap)
)


# %% [markdown]
# ## Combine LandDx and night-time  ecomap layers

# %%
# parameters

combine_landdx_np_layers_params = dict()

# %%
# call the task


combine_landdx_np_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_landdx_np_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_landdx_np_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_nightpr_ecomap_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

np_view_zip_params = dict()

# %%
# call the task


np_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="np_view_zip")
    .partial(left=combine_landdx_np_layers, right=zoom_traj_view, **np_view_zip_params)
    .call()
)


# %% [markdown]
# ## Draw night proportion ecomap

# %%
# parameters

draw_nightpr_ecomaps_params = dict()

# %%
# call the task


draw_nightpr_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_nightpr_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Night Time Fixes"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_nightpr_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=np_view_zip)
)


# %% [markdown]
# ## Persist night-proportion ecomap html paths

# %%
# parameters

persist_nightpr_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_nightpr_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_nightpr_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_nightpr_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_nightpr_ecomaps)
)


# %% [markdown]
# ## Create night-proportion Ecomap widgets

# %%
# parameters

create_nightpr_ecomap_widgets_params = dict()

# %%
# call the task


create_nightpr_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_nightpr_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(
        title="Proportion of night time fixes", **create_nightpr_ecomap_widgets_params
    )
    .map(argnames=["view", "data"], argvalues=persist_nightpr_ecomap_urls)
)


# %% [markdown]
# ## Merge night-time proportion Ecomap widgets

# %%
# parameters

merge_npr_ecomap_widgets_params = dict()

# %%
# call the task


merge_npr_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_npr_ecomap_widgets")
    .partial(widgets=create_nightpr_ecomap_widgets, **merge_npr_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Split dry season trajectories

# %%
# parameters

filter_dry_trajs_params = dict(
    include=...,
)

# %%
# call the task


filter_dry_trajs = (
    filter_column_values.handle_errors(task_instance_id="filter_dry_trajs")
    .partial(column="season", values=["dry"], **filter_dry_trajs_params)
    .mapvalues(argnames=["df"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Generate speed rasters

# %%
# parameters

generate_dry_speed_rasters_params = dict(
    filename=...,
    resolution=...,
    radius=...,
    cutoff=...,
    tortuosity_length=...,
    network_metric=...,
)

# %%
# call the task


generate_dry_speed_rasters = (
    generate_ecograph_raster.handle_errors(
        task_instance_id="generate_dry_speed_rasters"
    )
    .partial(
        dist_col="dist_meters",
        output_dir=create_output_directory,
        interpolation="mean",
        movement_covariate="speed",
        **generate_dry_speed_rasters_params,
    )
    .mapvalues(argnames=["gdf"], argvalues=filter_dry_trajs)
)


# %% [markdown]
# ## Extract features from dry speed raster TIFFs

# %%
# parameters

extract_dry_speed_rasters_params = dict()

# %%
# call the task


extract_dry_speed_rasters = (
    retrieve_feature_gdf.handle_errors(task_instance_id="extract_dry_speed_rasters")
    .partial(**extract_dry_speed_rasters_params)
    .mapvalues(argnames=["file_path"], argvalues=generate_dry_speed_rasters)
)


# %% [markdown]
# ## Sort speed features by value

# %%
# parameters

sort_dry_speed_features_params = dict(
    ascending=...,
)

# %%
# call the task


sort_dry_speed_features = (
    sort_values.handle_errors(task_instance_id="sort_dry_speed_features")
    .partial(column_name="value", na_position="last", **sort_dry_speed_features_params)
    .mapvalues(argnames=["df"], argvalues=extract_dry_speed_rasters)
)


# %% [markdown]
# ## Classify speed feature gdfs

# %%
# parameters

classify_dry_speed_features_params = dict()

# %%
# call the task


classify_dry_speed_features = (
    apply_classification.handle_errors(task_instance_id="classify_dry_speed_features")
    .partial(
        input_column_name="value",
        output_column_name="bins",
        classification_options={"scheme": "natural_breaks", "k": 6},
        label_options={"label_ranges": False, "label_decimals": 1},
        **classify_dry_speed_features_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_dry_speed_features)
)


# %% [markdown]
# ## Apply colormap to speed raster bins

# %%
# parameters

apply_dry_speed_colormap_params = dict()

# %%
# call the task


apply_dry_speed_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_dry_speed_colormap")
    .partial(
        input_column_name="bins",
        output_column_name="speedraster_bins_colors",
        colormap=["#1a9850", "#91cf60", "#d9ef8b", "#fee08b", "#fc8d59", "#d73027"],
        **apply_dry_speed_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=classify_dry_speed_features)
)


# %% [markdown]
# ## Format speed raster bin layers

# %%
# parameters

format_dry_raster_labels_params = dict()

# %%
# call the task


format_dry_raster_labels = (
    map_values_with_unit.handle_errors(task_instance_id="format_dry_raster_labels")
    .partial(
        input_column_name="bins",
        output_column_name="bins_formatted",
        original_unit="km/h",
        new_unit="km/h",
        decimal_places=1,
        **format_dry_raster_labels_params,
    )
    .mapvalues(argnames=["df"], argvalues=apply_dry_speed_colormap)
)


# %% [markdown]
# ## Create speed raster map layers

# %%
# parameters

generate_dry_raster_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_dry_raster_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_dry_raster_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "speedraster_bins_colors",
            "opacity": 0.25,
            "stroked": True,
        },
        legend={
            "label_column": "bins_formatted",
            "color_column": "speedraster_bins_colors",
        },
        tooltip_columns=["value", "bins", "speedraster_bins_colors"],
        **generate_dry_raster_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=format_dry_raster_labels)
)


# %% [markdown]
# ## Combine LandDx and speedraster layers

# %%
# parameters

combine_dry_seasonal_layers_params = dict()

# %%
# call the task


combine_dry_seasonal_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_dry_seasonal_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_dry_seasonal_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_dry_raster_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

dry_view_zip_params = dict()

# %%
# call the task


dry_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="dry_view_zip")
    .partial(
        left=combine_dry_seasonal_layers, right=zoom_traj_view, **dry_view_zip_params
    )
    .call()
)


# %% [markdown]
# ## Draw speed raster ecomap

# %%
# parameters

draw_dry_speed_ecomaps_params = dict()

# %%
# call the task


draw_dry_speed_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_dry_speed_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Raster Value(Km/h)"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_dry_speed_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=dry_view_zip)
)


# %% [markdown]
# ## Persist dry speed raster ecomap

# %%
# parameters

dry_raster_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


dry_raster_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="dry_raster_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **dry_raster_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_dry_speed_ecomaps)
)


# %% [markdown]
# ## Create dry speed raster widgets

# %%
# parameters

dry_single_ecomap_widgets_params = dict()

# %%
# call the task


dry_single_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="dry_single_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Dry Speed Raster Ecomap", **dry_single_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=dry_raster_ecomap_urls)
)


# %% [markdown]
# ## Merge dry speed raster widgets

# %%
# parameters

dry_raster_ecomap_widgets_params = dict()

# %%
# call the task


dry_raster_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="dry_raster_ecomap_widgets")
    .partial(widgets=dry_single_ecomap_widgets, **dry_raster_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Split wet season trajectories

# %%
# parameters

filter_wet_trajs_params = dict(
    include=...,
)

# %%
# call the task


filter_wet_trajs = (
    filter_column_values.handle_errors(task_instance_id="filter_wet_trajs")
    .partial(column="season", values=["wet"], **filter_wet_trajs_params)
    .mapvalues(argnames=["df"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Generate speed rasters

# %%
# parameters

generate_wet_speed_rasters_params = dict(
    filename=...,
    resolution=...,
    radius=...,
    cutoff=...,
    tortuosity_length=...,
    network_metric=...,
)

# %%
# call the task


generate_wet_speed_rasters = (
    generate_ecograph_raster.handle_errors(
        task_instance_id="generate_wet_speed_rasters"
    )
    .partial(
        dist_col="dist_meters",
        output_dir=create_output_directory,
        interpolation="mean",
        movement_covariate="speed",
        **generate_wet_speed_rasters_params,
    )
    .mapvalues(argnames=["gdf"], argvalues=filter_wet_trajs)
)


# %% [markdown]
# ## Extract features from wet speed raster TIFFs

# %%
# parameters

extract_wet_speed_rasters_params = dict()

# %%
# call the task


extract_wet_speed_rasters = (
    retrieve_feature_gdf.handle_errors(task_instance_id="extract_wet_speed_rasters")
    .partial(**extract_wet_speed_rasters_params)
    .mapvalues(argnames=["file_path"], argvalues=generate_wet_speed_rasters)
)


# %% [markdown]
# ## Sort speed features by value

# %%
# parameters

sort_wet_speed_features_params = dict(
    ascending=...,
)

# %%
# call the task


sort_wet_speed_features = (
    sort_values.handle_errors(task_instance_id="sort_wet_speed_features")
    .partial(column_name="value", na_position="last", **sort_wet_speed_features_params)
    .mapvalues(argnames=["df"], argvalues=extract_wet_speed_rasters)
)


# %% [markdown]
# ## Classify speed feature gdfs

# %%
# parameters

classify_wet_speed_features_params = dict()

# %%
# call the task


classify_wet_speed_features = (
    apply_classification.handle_errors(task_instance_id="classify_wet_speed_features")
    .partial(
        input_column_name="value",
        output_column_name="bins",
        classification_options={"scheme": "natural_breaks", "k": 6},
        label_options={"label_ranges": False, "label_decimals": 1},
        **classify_wet_speed_features_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_wet_speed_features)
)


# %% [markdown]
# ## Apply colormap to speed raster bins

# %%
# parameters

apply_wet_speed_colormap_params = dict()

# %%
# call the task


apply_wet_speed_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_wet_speed_colormap")
    .partial(
        input_column_name="bins",
        output_column_name="speedraster_bins_colors",
        colormap=["#1a9850", "#91cf60", "#d9ef8b", "#fee08b", "#fc8d59", "#d73027"],
        **apply_wet_speed_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=classify_wet_speed_features)
)


# %% [markdown]
# ## Format speed raster bin labels

# %%
# parameters

format_wet_raster_labels_params = dict()

# %%
# call the task


format_wet_raster_labels = (
    map_values_with_unit.handle_errors(task_instance_id="format_wet_raster_labels")
    .partial(
        input_column_name="bins",
        output_column_name="bins_formatted",
        original_unit="km/h",
        new_unit="km/h",
        decimal_places=1,
        **format_wet_raster_labels_params,
    )
    .mapvalues(argnames=["df"], argvalues=apply_wet_speed_colormap)
)


# %% [markdown]
# ## Create speed raster map layers

# %%
# parameters

generate_wet_raster_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_wet_raster_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_wet_raster_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "speedraster_bins_colors",
            "opacity": 0.25,
            "stroked": True,
        },
        legend={
            "label_column": "bins_formatted",
            "color_column": "speedraster_bins_colors",
        },
        tooltip_columns=["value", "bins", "speedraster_bins_colors"],
        **generate_wet_raster_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=format_wet_raster_labels)
)


# %% [markdown]
# ## Combine LandDx and speedraster map layers

# %%
# parameters

combine_wet_seasonal_layers_params = dict()

# %%
# call the task


combine_wet_seasonal_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_wet_seasonal_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_wet_seasonal_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_wet_raster_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

wets_view_zip_params = dict()

# %%
# call the task


wets_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="wets_view_zip")
    .partial(
        left=combine_wet_seasonal_layers, right=zoom_traj_view, **wets_view_zip_params
    )
    .call()
)


# %% [markdown]
# ## Draw speed raster ecomaps

# %%
# parameters

draw_wet_speed_ecomaps_params = dict()

# %%
# call the task


draw_wet_speed_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_wet_speed_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Raster Value(Km/h)"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_wet_speed_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=wets_view_zip)
)


# %% [markdown]
# ## Persist wet speed raster ecomap

# %%
# parameters

wet_raster_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


wet_raster_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="wet_raster_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **wet_raster_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_wet_speed_ecomaps)
)


# %% [markdown]
# ## Create wet speed raster ecomap widgets

# %%
# parameters

wet_single_ecomap_widgets_params = dict()

# %%
# call the task


wet_single_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="wet_single_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Wet Speed Raster Ecomap", **wet_single_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=wet_raster_ecomap_urls)
)


# %% [markdown]
# ## Merge wet speed raster ecomap widgets

# %%
# parameters

wet_raster_ecomap_widgets_params = dict()

# %%
# call the task


wet_raster_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="wet_raster_ecomap_widgets")
    .partial(widgets=wet_single_ecomap_widgets, **wet_raster_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Generate recursion events rasters

# %%
# parameters

generate_recursion_rasters_params = dict(
    filename=...,
    resolution=...,
    radius=...,
    cutoff=...,
    tortuosity_length=...,
    movement_covariate=...,
)

# %%
# call the task


generate_recursion_rasters = (
    generate_ecograph_raster.handle_errors(
        task_instance_id="generate_recursion_rasters"
    )
    .partial(
        dist_col="dist_meters",
        output_dir=create_output_directory,
        interpolation="mean",
        network_metric="weight",
        **generate_recursion_rasters_params,
    )
    .mapvalues(argnames=["gdf"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Extract recursion rasters

# %%
# parameters

extract_recursion_rasters_params = dict()

# %%
# call the task


extract_recursion_rasters = (
    retrieve_feature_gdf.handle_errors(task_instance_id="extract_recursion_rasters")
    .partial(**extract_recursion_rasters_params)
    .mapvalues(argnames=["file_path"], argvalues=generate_recursion_rasters)
)


# %% [markdown]
# ## Sort speed features by value

# %%
# parameters

sort_recursion_features_params = dict(
    ascending=...,
)

# %%
# call the task


sort_recursion_features = (
    sort_values.handle_errors(task_instance_id="sort_recursion_features")
    .partial(column_name="value", na_position="last", **sort_recursion_features_params)
    .mapvalues(argnames=["df"], argvalues=extract_recursion_rasters)
)


# %% [markdown]
# ## Classify recursion gdfs

# %%
# parameters

classify_recursion_features_params = dict()

# %%
# call the task


classify_recursion_features = (
    apply_classification.handle_errors(task_instance_id="classify_recursion_features")
    .partial(
        input_column_name="value",
        output_column_name="bins",
        classification_options={"scheme": "natural_breaks", "k": 6},
        label_options={"label_ranges": False, "label_decimals": 1},
        **classify_recursion_features_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_recursion_features)
)


# %% [markdown]
# ## Apply colormap to recursion bins

# %%
# parameters

apply_recursion_colormap_params = dict()

# %%
# call the task


apply_recursion_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_recursion_colormap")
    .partial(
        input_column_name="bins",
        output_column_name="recursion_bins_colors",
        colormap=["#1a9850", "#91cf60", "#d9ef8b", "#fee08b", "#fc8d59", "#d73027"],
        **apply_recursion_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=classify_recursion_features)
)


# %% [markdown]
# ## Create recursion raster map layers

# %%
# parameters

generate_recursion_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_recursion_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_recursion_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "recursion_bins_colors",
            "opacity": 0.25,
            "stroked": True,
        },
        legend={"label_column": "bins", "color_column": "recursion_bins_colors"},
        tooltip_columns=["value", "bins", "recursion_bins_colors"],
        **generate_recursion_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=apply_recursion_colormap)
)


# %% [markdown]
# ## Combine LandDx and recursion raster map layers

# %%
# parameters

combine_recursion_layers_params = dict()

# %%
# call the task


combine_recursion_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_recursion_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_recursion_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_recursion_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

recursion_view_zip_params = dict()

# %%
# call the task


recursion_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="recursion_view_zip")
    .partial(
        left=combine_recursion_layers, right=zoom_traj_view, **recursion_view_zip_params
    )
    .call()
)


# %% [markdown]
# ## Draw recursion raster ecomaps

# %%
# parameters

draw_recursion_ecomaps_params = dict()

# %%
# call the task


draw_recursion_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_recursion_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Recursion Events"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_recursion_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=recursion_view_zip)
)


# %% [markdown]
# ## Persist recursion raster ecomaps

# %%
# parameters

recursion_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


recursion_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="recursion_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **recursion_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_recursion_ecomaps)
)


# %% [markdown]
# ## Create recursion raster ecomap widgets

# %%
# parameters

recursion_ecomap_widgets_params = dict()

# %%
# call the task


recursion_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="recursion_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Recursion Events Raster Ecomap", **recursion_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=recursion_ecomap_urls)
)


# %% [markdown]
# ## Merge recursion raster ecomap widgets

# %%
# parameters

reraster_ecomap_widgets_params = dict()

# %%
# call the task


reraster_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="reraster_ecomap_widgets")
    .partial(widgets=recursion_ecomap_widgets, **reraster_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Split protected trajectories

# %%
# parameters

filter_protected_trajs_params = dict(
    include=...,
)

# %%
# call the task


filter_protected_trajs = (
    filter_column_values.handle_errors(task_instance_id="filter_protected_trajs")
    .partial(
        column="area_status", values=["protected"], **filter_protected_trajs_params
    )
    .mapvalues(argnames=["df"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Generate home range

# %%
# parameters

generate_protected_etd_params = dict(
    auto_scale_or_custom_cell_size=...,
    max_speed_factor=...,
    expansion_factor=...,
)

# %%
# call the task


generate_protected_etd = (
    calculate_elliptical_time_density.handle_errors(
        task_instance_id="generate_protected_etd"
    )
    .partial(
        crs="ESRI:53042",
        percentiles=[50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
        nodata_value="nan",
        band_count=1,
        **generate_protected_etd_params,
    )
    .mapvalues(argnames=["trajectory_gdf"], argvalues=filter_protected_trajs)
)


# %% [markdown]
# ## Time density colormap

# %%
# parameters

td_protected_colormap_params = dict()

# %%
# call the task


td_protected_colormap = (
    apply_color_map.handle_errors(task_instance_id="td_protected_colormap")
    .partial(
        input_column_name="percentile",
        colormap="RdYlGn",
        output_column_name="percentile_colormap",
        **td_protected_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=generate_protected_etd)
)


# %% [markdown]
# ## Create home range ecomap layers

# %%
# parameters

generate_etd_protected_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_etd_protected_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_etd_protected_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "percentile_colormap",
            "opacity": 0.25,
            "stroked": False,
        },
        legend={"label_column": "percentile", "color_column": "percentile_colormap"},
        tooltip_columns=["percentile"],
        **generate_etd_protected_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=td_protected_colormap)
)


# %% [markdown]
# ## Combine LandDx and hr ecomap layers

# %%
# parameters

combine_ldx_protected_layers_params = dict()

# %%
# call the task


combine_ldx_protected_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_ldx_protected_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_ldx_protected_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_etd_protected_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

prot_view_zip_params = dict()

# %%
# call the task


prot_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="prot_view_zip")
    .partial(
        left=combine_ldx_protected_layers, right=zoom_traj_view, **prot_view_zip_params
    )
    .call()
)


# %% [markdown]
# ## Draw hr ecomaps

# %%
# parameters

draw_protected_ecomaps_params = dict()

# %%
# call the task


draw_protected_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_protected_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Home Range Metrics"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_protected_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=prot_view_zip)
)


# %% [markdown]
# ## Persist protected hr ecomaps

# %%
# parameters

persist_protected_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_protected_urls = (
    persist_text.handle_errors(task_instance_id="persist_protected_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_protected_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_protected_ecomaps)
)


# %% [markdown]
# ## Create protected hr ecomap widgets

# %%
# parameters

create_protected_widgets_params = dict()

# %%
# call the task


create_protected_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_protected_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Protected Home Range Ecomap", **create_protected_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_protected_urls)
)


# %% [markdown]
# ## Merge protected home range ecomap widgets

# %%
# parameters

merge_protected_widgets_params = dict()

# %%
# call the task


merge_protected_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_protected_widgets")
    .partial(widgets=create_protected_widgets, **merge_protected_widgets_params)
    .call()
)


# %% [markdown]
# ## Split unprotected trajectories

# %%
# parameters

filter_unprotected_trajs_params = dict(
    include=...,
)

# %%
# call the task


filter_unprotected_trajs = (
    filter_column_values.handle_errors(task_instance_id="filter_unprotected_trajs")
    .partial(
        column="area_status", values=["unprotected"], **filter_unprotected_trajs_params
    )
    .mapvalues(argnames=["df"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Generate home range

# %%
# parameters

generate_unprotected_etd_params = dict(
    auto_scale_or_custom_cell_size=...,
    max_speed_factor=...,
    expansion_factor=...,
)

# %%
# call the task


generate_unprotected_etd = (
    calculate_elliptical_time_density.handle_errors(
        task_instance_id="generate_unprotected_etd"
    )
    .partial(
        crs="ESRI:53042",
        percentiles=[50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
        nodata_value="nan",
        band_count=1,
        **generate_unprotected_etd_params,
    )
    .mapvalues(argnames=["trajectory_gdf"], argvalues=filter_unprotected_trajs)
)


# %% [markdown]
# ## Time density colormap

# %%
# parameters

td_unprotected_colormap_params = dict()

# %%
# call the task


td_unprotected_colormap = (
    apply_color_map.handle_errors(task_instance_id="td_unprotected_colormap")
    .partial(
        input_column_name="percentile",
        colormap="RdYlGn",
        output_column_name="percentile_colormap",
        **td_unprotected_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=generate_unprotected_etd)
)


# %% [markdown]
# ## Create unprotected home range ecomap layers

# %%
# parameters

generate_unprotected_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_unprotected_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_unprotected_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={
            "fill_color_column": "percentile_colormap",
            "opacity": 0.25,
            "stroked": False,
        },
        legend={"label_column": "percentile", "color_column": "percentile_colormap"},
        tooltip_columns=["percentile"],
        **generate_unprotected_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=td_unprotected_colormap)
)


# %% [markdown]
# ## Combine LandDx and hr ecomap layers

# %%
# parameters

combine_ldx_unprotected_layers_params = dict()

# %%
# call the task


combine_ldx_unprotected_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_ldx_unprotected_layers")
    .partial(
        static_layers=create_styled_landdx_layers,
        **combine_ldx_unprotected_layers_params,
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_unprotected_layers)
)


# %% [markdown]
# ## Zip layers and viewstate

# %%
# parameters

unprot_view_zip_params = dict()

# %%
# call the task


unprot_view_zip = (
    zip_grouped_by_key.handle_errors(task_instance_id="unprot_view_zip")
    .partial(
        left=combine_ldx_unprotected_layers,
        right=zoom_traj_view,
        **unprot_view_zip_params,
    )
    .call()
)


# %% [markdown]
# ## Draw unprotected hr ecomap

# %%
# parameters

draw_unprotected_ecomaps_params = dict()

# %%
# call the task


draw_unprotected_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_unprotected_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right", "title": "Home Range Metrics"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_unprotected_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers", "view_state"], argvalues=unprot_view_zip)
)


# %% [markdown]
# ## Persist unprotected home range ecomap

# %%
# parameters

persist_unprotected_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_unprotected_urls = (
    persist_text.handle_errors(task_instance_id="persist_unprotected_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_unprotected_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_unprotected_ecomaps)
)


# %% [markdown]
# ## Create unprotected home range ecomap widgets

# %%
# parameters

create_unprotected_widgets_params = dict()

# %%
# call the task


create_unprotected_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_unprotected_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Unprotected Home Range Ecomap", **create_unprotected_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_unprotected_urls)
)


# %% [markdown]
# ## Merge unprotected home range widgets

# %%
# parameters

merge_unprotected_widgets_params = dict()

# %%
# call the task


merge_unprotected_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_unprotected_widgets")
    .partial(widgets=create_unprotected_widgets, **merge_unprotected_widgets_params)
    .call()
)


# %% [markdown]
# ## Protected-unprotected summary table

# %%
# parameters

unpr_category_summary_params = dict(
    values=...,
    agg=...,
    fill_value=...,
    pct_suffix=...,
    round_pct=...,
    reset_index=...,
)

# %%
# call the task


unpr_category_summary = (
    category_summary.handle_errors(task_instance_id="unpr_category_summary")
    .partial(
        group_cols=["extra__name", "season"],
        category_col="area_status",
        pct_for=["protected", "unprotected"],
        **unpr_category_summary_params,
    )
    .mapvalues(argnames=["df"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Plot protected-unprotected areas

# %%
# parameters

plot_prot_unprot_params = dict()

# %%
# call the task


plot_prot_unprot = (
    plot_protected_fix_proportions.handle_errors(task_instance_id="plot_prot_unprot")
    .partial(title="proportion", **plot_prot_unprot_params)
    .mapvalues(argnames=["summary"], argvalues=unpr_category_summary)
)


# %% [markdown]
# ## Persist protected-unprotected chart

# %%
# parameters

persist_pr_chart_params = dict(
    filename=...,
)

# %%
# call the task


persist_pr_chart = (
    persist_text.handle_errors(task_instance_id="persist_pr_chart")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"], **persist_pr_chart_params
    )
    .mapvalues(argnames=["text"], argvalues=plot_prot_unprot)
)


# %% [markdown]
# ## create plot widget

# %%
# parameters

create_single_prot_widget_params = dict()

# %%
# call the task


create_single_prot_widget = (
    create_plot_widget_single_view.handle_errors(
        task_instance_id="create_single_prot_widget"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Proportion of Fixes", **create_single_prot_widget_params)
    .map(argnames=["view", "data"], argvalues=persist_pr_chart)
)


# %% [markdown]
# ## Merge plot widgets

# %%
# parameters

merge_prot_widgets_params = dict()

# %%
# call the task


merge_prot_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_prot_widgets")
    .partial(widgets=create_single_prot_widget, **merge_prot_widgets_params)
    .call()
)


# %% [markdown]
# ## Mapbook Dashboard

# %%
# parameters

mapbook_dashboard_params = dict()

# %%
# call the task


mapbook_dashboard = (
    gather_dashboard.handle_errors(task_instance_id="mapbook_dashboard")
    .partial(
        details=initialize_workflow_metadata,
        widgets=[
            merge_substyled_widgets,
            merge_hr_ecomap_widgets,
            merge_custom_hr_ecomap_widgets,
            merge_season_ecomap_widgets,
            merge_td_ecomap_widgets,
            merge_npr_ecomap_widgets,
            dry_raster_ecomap_widgets,
            wet_raster_ecomap_widgets,
            reraster_ecomap_widgets,
            merge_protected_widgets,
            merge_unprotected_widgets,
            merge_prot_widgets,
        ],
        time_range=define_time_range,
        groupers=configure_grouping_strategy,
        **mapbook_dashboard_params,
    )
    .call()
)
