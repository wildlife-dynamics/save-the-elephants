# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details

# ruff: noqa: E402

"""WARNING: This file is generated in a testing context and should not be used in production.
Lines specific to the testing context are marked with a test tube emoji (ðŸ§ª) to indicate
that they would not be included (or would be different) in the production version of this file.
"""

import json
import os
import warnings  # ðŸ§ª
from ecoscope_workflows_core.testing import create_task_magicmock  # ðŸ§ª


from ecoscope_workflows_core.graph import DependsOn, DependsOnSequence, Graph, Node

from ecoscope_workflows_core.tasks.config import set_workflow_details
from ecoscope_workflows_core.tasks.filter import set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers
from ecoscope_workflows_ext_ecoscope.tasks.results import set_base_maps
from ecoscope_workflows_ext_ste.tasks import create_directory
from ecoscope_workflows_ext_ste.tasks import download_land_dx
from ecoscope_workflows_ext_ste.tasks import load_landdx_aoi
from ecoscope_workflows_ext_ste.tasks import split_gdf_by_column
from ecoscope_workflows_ext_ste.tasks import annotate_gdf_dict_with_geometry_type
from ecoscope_workflows_ext_ste.tasks import create_map_layers_from_annotated_dict
from ecoscope_workflows_core.tasks.io import set_er_connection
from ecoscope_workflows_core.tasks.io import set_gee_connection

get_subjectgroup_observations = create_task_magicmock(  # ðŸ§ª
    anchor="ecoscope_workflows_ext_ecoscope.tasks.io",  # ðŸ§ª
    func_name="get_subjectgroup_observations",  # ðŸ§ª
)  # ðŸ§ª
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import process_relocations
from ecoscope_workflows_ext_ecoscope.tasks.transformation import classify_is_night
from ecoscope_workflows_ext_ste.tasks import add_day_night_column
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import (
    relocations_to_trajectory,
)
from ecoscope_workflows_core.tasks.transformation import add_temporal_index
from ecoscope_workflows_ext_ecoscope.tasks.transformation import apply_classification
from ecoscope_workflows_ext_ecoscope.tasks.analysis import (
    calculate_elliptical_time_density,
)

determine_season_windows = create_task_magicmock(  # ðŸ§ª
    anchor="ecoscope_workflows_ext_ecoscope.tasks.io",  # ðŸ§ª
    func_name="determine_season_windows",  # ðŸ§ª
)  # ðŸ§ª
from ecoscope_workflows_ext_ste.tasks import create_seasonal_labels
from ecoscope_workflows_ext_ste.tasks import convert_col_to_rgba
from ecoscope_workflows_ext_ecoscope.tasks.analysis import create_meshgrid
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df
from ecoscope_workflows_ext_ste.tasks import assign_column
from ecoscope_workflows_ext_ste.tasks import spatial_join
from ecoscope_workflows_ext_ste.tasks import assign_value_by_index
from ecoscope_workflows_ext_ste.tasks import view_df
from ecoscope_workflows_core.tasks.groupby import split_groups
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polyline_layer
from ecoscope_workflows_core.tasks.skip import any_is_empty_df
from ecoscope_workflows_core.tasks.skip import any_dependency_skipped
from ecoscope_workflows_ext_ste.tasks import combine_map_layers
from ecoscope_workflows_ext_ecoscope.tasks.results import draw_ecomap
from ecoscope_workflows_core.tasks.io import persist_text
from ecoscope_workflows_core.tasks.results import create_map_widget_single_view
from ecoscope_workflows_core.tasks.skip import never
from ecoscope_workflows_core.tasks.results import merge_widget_views
from ecoscope_workflows_ext_ecoscope.tasks.transformation import apply_color_map
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polygon_layer
from ecoscope_workflows_ext_ste.tasks import filter_column_values
from ecoscope_workflows_ext_ste.tasks import calculate_etd_by_groups
from ecoscope_workflows_core.tasks.transformation import sort_values
from ecoscope_workflows_ext_ste.tasks import compute_fix_density_and_night_class
from ecoscope_workflows_ext_ste.tasks import filter_time_dominance
from ecoscope_workflows_ext_ecoscope.tasks.transformation import (
    drop_nan_values_by_column,
)
from ecoscope_workflows_ext_ste.tasks import drop_missing_values_by_column
from ecoscope_workflows_ext_ste.tasks import generate_ecograph_raster
from ecoscope_workflows_ext_ste.tasks import retrieve_feature_gdf
from ecoscope_workflows_core.tasks.transformation import map_values_with_unit
from ecoscope_workflows_ext_ste.tasks import category_summary
from ecoscope_workflows_ext_ste.tasks import plot_protected_fix_proportions
from ecoscope_workflows_core.tasks.results import create_plot_widget_single_view
from ecoscope_workflows_core.tasks.results import gather_dashboard

from ..params import Params


def main(params: Params):
    warnings.warn("This test script should not be used in production!")  # ðŸ§ª

    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "initialize_workflow_metadata": [],
        "define_time_range": [],
        "configure_grouping_strategy": [],
        "configure_base_maps": [],
        "create_output_directory": [],
        "retrieve_landdx_database": ["create_output_directory"],
        "load_aoi": ["retrieve_landdx_database"],
        "split_landdx_by_type": ["load_aoi"],
        "annotate_geometry_types": ["split_landdx_by_type"],
        "create_styled_landdx_layers": ["annotate_geometry_types"],
        "er_client_name": [],
        "gee_project_name": [],
        "subject_observations": ["er_client_name", "define_time_range"],
        "subject_reloc": ["subject_observations"],
        "annotate_day_night": ["subject_reloc"],
        "day_night_column": ["annotate_day_night"],
        "convert_to_trajectories": ["day_night_column"],
        "add_temporal_index_to_traj": [
            "convert_to_trajectories",
            "configure_grouping_strategy",
        ],
        "classify_trajectory_speed_bins": ["add_temporal_index_to_traj"],
        "generate_seasonal_etd": ["classify_trajectory_speed_bins"],
        "determine_seasonal_windows": [
            "gee_project_name",
            "generate_seasonal_etd",
            "define_time_range",
        ],
        "add_season_labels": [
            "classify_trajectory_speed_bins",
            "determine_seasonal_windows",
        ],
        "convert_hex_rgba": ["add_season_labels"],
        "create_dn_meshgrid": ["day_night_column"],
        "persist_traj_df": ["convert_hex_rgba", "create_output_directory"],
        "persist_relocs_df": ["day_night_column", "create_output_directory"],
        "assign_cols": ["convert_hex_rgba"],
        "join_traj_landdx": ["load_aoi", "assign_cols"],
        "assign_protected_values": ["assign_cols", "join_traj_landdx"],
        "view_joined_gdf": ["assign_protected_values"],
        "split_trajectories_by_group": [
            "assign_protected_values",
            "configure_grouping_strategy",
        ],
        "split_relocations_by_group": [
            "day_night_column",
            "configure_grouping_strategy",
        ],
        "generate_substyled_layers": ["split_trajectories_by_group"],
        "combine_substyled_layers": [
            "create_styled_landdx_layers",
            "generate_substyled_layers",
        ],
        "draw_substyled_ecomaps": ["configure_base_maps", "combine_substyled_layers"],
        "persist_substyled_urls": ["draw_substyled_ecomaps"],
        "create_substyled_ecomap_widgets": ["persist_substyled_urls"],
        "merge_substyled_widgets": ["create_substyled_ecomap_widgets"],
        "generate_etd": ["split_trajectories_by_group"],
        "td_colormap": ["generate_etd"],
        "generate_etd_ecomap_layers": ["td_colormap"],
        "combine_landdx_hr_ecomap_layers": [
            "create_styled_landdx_layers",
            "generate_etd_ecomap_layers",
        ],
        "draw_hr_ecomaps": ["configure_base_maps", "combine_landdx_hr_ecomap_layers"],
        "persist_hr_ecomap_urls": ["draw_hr_ecomaps"],
        "create_hr_ecomap_widgets": ["persist_hr_ecomap_urls"],
        "merge_hr_ecomap_widgets": ["create_hr_ecomap_widgets"],
        "custom_hr": ["generate_etd"],
        "custom_td_colormap": ["custom_hr"],
        "generate_cetd_ecomap_layers": ["custom_td_colormap"],
        "combine_landdx_custom_hr_layers": [
            "create_styled_landdx_layers",
            "generate_cetd_ecomap_layers",
        ],
        "draw_custom_hr_ecomaps": [
            "configure_base_maps",
            "combine_landdx_custom_hr_layers",
        ],
        "persist_custom_hr_ecomap_urls": ["draw_custom_hr_ecomaps"],
        "create_custom_hr_ecomap_widgets": ["persist_custom_hr_ecomap_urls"],
        "merge_custom_hr_ecomap_widgets": ["create_custom_hr_ecomap_widgets"],
        "generate_season_etd": ["split_trajectories_by_group"],
        "sort_season_etd_color": ["generate_season_etd"],
        "apply_season_etd_colormap": ["sort_season_etd_color"],
        "generate_season_ecomap_layers": ["apply_season_etd_colormap"],
        "combine_landdx_season_layers": [
            "create_styled_landdx_layers",
            "generate_season_ecomap_layers",
        ],
        "draw_season_ecomaps": ["configure_base_maps", "combine_landdx_season_layers"],
        "persist_season_ecomap_urls": ["draw_season_ecomaps"],
        "create_season_ecomap_widgets": ["persist_season_ecomap_urls"],
        "merge_season_ecomap_widgets": ["create_season_ecomap_widgets"],
        "time_dominance": ["create_dn_meshgrid", "split_relocations_by_group"],
        "filter_dominance_values": ["time_dominance"],
        "sort_dominance_values": ["filter_dominance_values"],
        "apply_dn_dom_colormap": ["sort_dominance_values"],
        "generate_td_ecomap_layers": ["apply_dn_dom_colormap"],
        "combine_landdx_td_layers": [
            "create_styled_landdx_layers",
            "generate_td_ecomap_layers",
        ],
        "draw_tdominance_ecomaps": ["configure_base_maps", "combine_landdx_td_layers"],
        "persist_tdominance_ecomap_urls": ["draw_tdominance_ecomaps"],
        "create_tdom_ecomap_widgets": ["persist_tdominance_ecomap_urls"],
        "merge_td_ecomap_widgets": ["create_tdom_ecomap_widgets"],
        "night_proportion_fixes": ["create_dn_meshgrid", "split_relocations_by_group"],
        "sort_night_proportion_values": ["night_proportion_fixes"],
        "drop_nan_proportion_values": ["sort_night_proportion_values"],
        "drop_nan_threshold_values": ["drop_nan_proportion_values"],
        "apply_nightpr_colormap": ["drop_nan_threshold_values"],
        "generate_nightpr_ecomap_layers": ["apply_nightpr_colormap"],
        "combine_landdx_np_layers": [
            "create_styled_landdx_layers",
            "generate_nightpr_ecomap_layers",
        ],
        "draw_nightpr_ecomaps": ["configure_base_maps", "combine_landdx_np_layers"],
        "persist_nightpr_ecomap_urls": ["draw_nightpr_ecomaps"],
        "create_nightpr_ecomap_widgets": ["persist_nightpr_ecomap_urls"],
        "merge_npr_ecomap_widgets": ["create_nightpr_ecomap_widgets"],
        "filter_dry_trajs": ["split_trajectories_by_group"],
        "generate_dry_speed_rasters": ["create_output_directory", "filter_dry_trajs"],
        "extract_dry_speed_rasters": ["generate_dry_speed_rasters"],
        "sort_dry_speed_features": ["extract_dry_speed_rasters"],
        "classify_dry_speed_features": ["sort_dry_speed_features"],
        "apply_dry_speed_colormap": ["classify_dry_speed_features"],
        "format_dry_raster_labels": ["apply_dry_speed_colormap"],
        "generate_dry_raster_layers": ["format_dry_raster_labels"],
        "combine_dry_seasonal_layers": [
            "create_styled_landdx_layers",
            "generate_dry_raster_layers",
        ],
        "draw_dry_speed_ecomaps": [
            "configure_base_maps",
            "combine_dry_seasonal_layers",
        ],
        "dry_raster_ecomap_urls": ["draw_dry_speed_ecomaps"],
        "dry_single_ecomap_widgets": ["dry_raster_ecomap_urls"],
        "dry_raster_ecomap_widgets": ["dry_single_ecomap_widgets"],
        "filter_wet_trajs": ["split_trajectories_by_group"],
        "generate_wet_speed_rasters": ["create_output_directory", "filter_wet_trajs"],
        "extract_wet_speed_rasters": ["generate_wet_speed_rasters"],
        "sort_wet_speed_features": ["extract_wet_speed_rasters"],
        "classify_wet_speed_features": ["sort_wet_speed_features"],
        "apply_wet_speed_colormap": ["classify_wet_speed_features"],
        "format_wet_raster_labels": ["apply_wet_speed_colormap"],
        "generate_wet_raster_layers": ["format_wet_raster_labels"],
        "combine_wet_seasonal_layers": [
            "create_styled_landdx_layers",
            "generate_wet_raster_layers",
        ],
        "draw_wet_speed_ecomaps": [
            "configure_base_maps",
            "combine_wet_seasonal_layers",
        ],
        "wet_raster_ecomap_urls": ["draw_wet_speed_ecomaps"],
        "wet_single_ecomap_widgets": ["wet_raster_ecomap_urls"],
        "wet_raster_ecomap_widgets": ["wet_single_ecomap_widgets"],
        "generate_recursion_rasters": [
            "create_output_directory",
            "split_trajectories_by_group",
        ],
        "extract_recursion_rasters": ["generate_recursion_rasters"],
        "sort_recursion_features": ["extract_recursion_rasters"],
        "classify_recursion_features": ["sort_recursion_features"],
        "apply_recursion_colormap": ["classify_recursion_features"],
        "generate_recursion_layers": ["apply_recursion_colormap"],
        "combine_recursion_layers": [
            "create_styled_landdx_layers",
            "generate_recursion_layers",
        ],
        "draw_recursion_ecomaps": ["configure_base_maps", "combine_recursion_layers"],
        "recursion_ecomap_urls": ["draw_recursion_ecomaps"],
        "recursion_ecomap_widgets": ["recursion_ecomap_urls"],
        "reraster_ecomap_widgets": ["recursion_ecomap_widgets"],
        "filter_protected_trajs": ["split_trajectories_by_group"],
        "generate_protected_etd": ["filter_protected_trajs"],
        "td_protected_colormap": ["generate_protected_etd"],
        "generate_etd_protected_layers": ["td_protected_colormap"],
        "combine_ldx_protected_layers": [
            "create_styled_landdx_layers",
            "generate_etd_protected_layers",
        ],
        "draw_protected_ecomaps": [
            "configure_base_maps",
            "combine_ldx_protected_layers",
        ],
        "persist_protected_urls": ["draw_protected_ecomaps"],
        "create_protected_widgets": ["persist_protected_urls"],
        "merge_protected_widgets": ["create_protected_widgets"],
        "filter_unprotected_trajs": ["split_trajectories_by_group"],
        "generate_unprotected_etd": ["filter_unprotected_trajs"],
        "td_unprotected_colormap": ["generate_unprotected_etd"],
        "generate_unprotected_layers": ["td_unprotected_colormap"],
        "combine_ldx_unprotected_layers": [
            "create_styled_landdx_layers",
            "generate_unprotected_layers",
        ],
        "draw_unprotected_ecomaps": [
            "configure_base_maps",
            "combine_ldx_unprotected_layers",
        ],
        "persist_unprotected_urls": ["draw_unprotected_ecomaps"],
        "create_unprotected_widgets": ["persist_unprotected_urls"],
        "merge_unprotected_widgets": ["create_unprotected_widgets"],
        "unpr_category_summary": ["split_trajectories_by_group"],
        "plot_prot_unprot": ["unpr_category_summary"],
        "persist_pr_chart": ["plot_prot_unprot"],
        "create_single_prot_widget": ["persist_pr_chart"],
        "merge_prot_widgets": ["create_single_prot_widget"],
        "view_prot_df": ["unpr_category_summary"],
        "mapbook_dashboard": [
            "initialize_workflow_metadata",
            "merge_substyled_widgets",
            "merge_hr_ecomap_widgets",
            "merge_custom_hr_ecomap_widgets",
            "merge_season_ecomap_widgets",
            "merge_td_ecomap_widgets",
            "merge_npr_ecomap_widgets",
            "dry_raster_ecomap_widgets",
            "wet_raster_ecomap_widgets",
            "reraster_ecomap_widgets",
            "merge_protected_widgets",
            "merge_unprotected_widgets",
            "merge_prot_widgets",
            "define_time_range",
            "configure_grouping_strategy",
        ],
    }

    nodes = {
        "initialize_workflow_metadata": Node(
            async_task=set_workflow_details.validate()
            .handle_errors(task_instance_id="initialize_workflow_metadata")
            .set_executor("lithops"),
            partial=(params_dict.get("initialize_workflow_metadata") or {}),
            method="call",
        ),
        "define_time_range": Node(
            async_task=set_time_range.validate()
            .handle_errors(task_instance_id="define_time_range")
            .set_executor("lithops"),
            partial={
                "time_format": "%d %b %Y %H:%M:%S %Z",
            }
            | (params_dict.get("define_time_range") or {}),
            method="call",
        ),
        "configure_grouping_strategy": Node(
            async_task=set_groupers.validate()
            .handle_errors(task_instance_id="configure_grouping_strategy")
            .set_executor("lithops"),
            partial=(params_dict.get("configure_grouping_strategy") or {}),
            method="call",
        ),
        "configure_base_maps": Node(
            async_task=set_base_maps.validate()
            .handle_errors(task_instance_id="configure_base_maps")
            .set_executor("lithops"),
            partial=(params_dict.get("configure_base_maps") or {}),
            method="call",
        ),
        "create_output_directory": Node(
            async_task=create_directory.validate()
            .handle_errors(task_instance_id="create_output_directory")
            .set_executor("lithops"),
            partial=(params_dict.get("create_output_directory") or {}),
            method="call",
        ),
        "retrieve_landdx_database": Node(
            async_task=download_land_dx.validate()
            .handle_errors(task_instance_id="retrieve_landdx_database")
            .set_executor("lithops"),
            partial={
                "path": DependsOn("create_output_directory"),
            }
            | (params_dict.get("retrieve_landdx_database") or {}),
            method="call",
        ),
        "load_aoi": Node(
            async_task=load_landdx_aoi.validate()
            .handle_errors(task_instance_id="load_aoi")
            .set_executor("lithops"),
            partial={
                "map_path": DependsOn("retrieve_landdx_database"),
            }
            | (params_dict.get("load_aoi") or {}),
            method="call",
        ),
        "split_landdx_by_type": Node(
            async_task=split_gdf_by_column.validate()
            .handle_errors(task_instance_id="split_landdx_by_type")
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("load_aoi"),
                "column": "type",
            }
            | (params_dict.get("split_landdx_by_type") or {}),
            method="call",
        ),
        "annotate_geometry_types": Node(
            async_task=annotate_gdf_dict_with_geometry_type.validate()
            .handle_errors(task_instance_id="annotate_geometry_types")
            .set_executor("lithops"),
            partial={
                "gdf_dict": DependsOn("split_landdx_by_type"),
            }
            | (params_dict.get("annotate_geometry_types") or {}),
            method="call",
        ),
        "create_styled_landdx_layers": Node(
            async_task=create_map_layers_from_annotated_dict.validate()
            .handle_errors(task_instance_id="create_styled_landdx_layers")
            .set_executor("lithops"),
            partial={
                "annotated_dict": DependsOn("annotate_geometry_types"),
            }
            | (params_dict.get("create_styled_landdx_layers") or {}),
            method="call",
        ),
        "er_client_name": Node(
            async_task=set_er_connection.validate()
            .handle_errors(task_instance_id="er_client_name")
            .set_executor("lithops"),
            partial=(params_dict.get("er_client_name") or {}),
            method="call",
        ),
        "gee_project_name": Node(
            async_task=set_gee_connection.validate()
            .handle_errors(task_instance_id="gee_project_name")
            .set_executor("lithops"),
            partial=(params_dict.get("gee_project_name") or {}),
            method="call",
        ),
        "subject_observations": Node(
            async_task=get_subjectgroup_observations.validate()
            .handle_errors(task_instance_id="subject_observations")
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("define_time_range"),
                "raise_on_empty": False,
                "include_details": False,
                "include_subjectsource_details": False,
            }
            | (params_dict.get("subject_observations") or {}),
            method="call",
        ),
        "subject_reloc": Node(
            async_task=process_relocations.validate()
            .handle_errors(task_instance_id="subject_reloc")
            .set_executor("lithops"),
            partial={
                "observations": DependsOn("subject_observations"),
                "relocs_columns": [
                    "fixtime",
                    "geometry",
                    "groupby_col",
                    "junk_status",
                    "extra__created_at",
                    "extra__subject__sex",
                    "extra__subject__hex",
                    "extra__subject__name",
                    "extra__subject__subject_subtype",
                ],
                "filter_point_coords": [
                    {"x": 180.0, "y": 90.0},
                    {"x": 0.0, "y": 0.0},
                    {"x": 1.0, "y": 1.0},
                ],
            }
            | (params_dict.get("subject_reloc") or {}),
            method="call",
        ),
        "annotate_day_night": Node(
            async_task=classify_is_night.validate()
            .handle_errors(task_instance_id="annotate_day_night")
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("subject_reloc"),
            }
            | (params_dict.get("annotate_day_night") or {}),
            method="call",
        ),
        "day_night_column": Node(
            async_task=add_day_night_column.validate()
            .handle_errors(task_instance_id="day_night_column")
            .set_executor("lithops"),
            partial={
                "source_col": "is_night",
                "df": DependsOn("annotate_day_night"),
            }
            | (params_dict.get("day_night_column") or {}),
            method="call",
        ),
        "convert_to_trajectories": Node(
            async_task=relocations_to_trajectory.validate()
            .handle_errors(task_instance_id="convert_to_trajectories")
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("day_night_column"),
            }
            | (params_dict.get("convert_to_trajectories") or {}),
            method="call",
        ),
        "add_temporal_index_to_traj": Node(
            async_task=add_temporal_index.validate()
            .handle_errors(task_instance_id="add_temporal_index_to_traj")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("convert_to_trajectories"),
                "time_col": "segment_start",
                "groupers": DependsOn("configure_grouping_strategy"),
                "cast_to_datetime": True,
                "format": "mixed",
            }
            | (params_dict.get("add_temporal_index_to_traj") or {}),
            method="call",
        ),
        "classify_trajectory_speed_bins": Node(
            async_task=apply_classification.validate()
            .handle_errors(task_instance_id="classify_trajectory_speed_bins")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("add_temporal_index_to_traj"),
                "input_column_name": "speed_kmhr",
                "output_column_name": "speed_bins",
                "classification_options": {"scheme": "equal_interval", "k": 6},
                "label_options": {"label_ranges": False, "label_decimals": 1},
            }
            | (params_dict.get("classify_trajectory_speed_bins") or {}),
            method="call",
        ),
        "generate_seasonal_etd": Node(
            async_task=calculate_elliptical_time_density.validate()
            .handle_errors(task_instance_id="generate_seasonal_etd")
            .set_executor("lithops"),
            partial={
                "crs": "ESRI:53042",
                "percentiles": [50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
                "nodata_value": "nan",
                "band_count": 1,
                "trajectory_gdf": DependsOn("classify_trajectory_speed_bins"),
            }
            | (params_dict.get("generate_seasonal_etd") or {}),
            method="call",
        ),
        "determine_seasonal_windows": Node(
            async_task=determine_season_windows.validate()
            .handle_errors(task_instance_id="determine_seasonal_windows")
            .set_executor("lithops"),
            partial={
                "client": DependsOn("gee_project_name"),
                "roi": DependsOn("generate_seasonal_etd"),
                "time_range": DependsOn("define_time_range"),
            }
            | (params_dict.get("determine_seasonal_windows") or {}),
            method="call",
        ),
        "add_season_labels": Node(
            async_task=create_seasonal_labels.validate()
            .handle_errors(task_instance_id="add_season_labels")
            .set_executor("lithops"),
            partial={
                "traj": DependsOn("classify_trajectory_speed_bins"),
                "total_percentiles": DependsOn("determine_seasonal_windows"),
            }
            | (params_dict.get("add_season_labels") or {}),
            method="call",
        ),
        "convert_hex_rgba": Node(
            async_task=convert_col_to_rgba.validate()
            .handle_errors(task_instance_id="convert_hex_rgba")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("add_season_labels"),
                "col": "extra__hex",
                "new_col": "hex_colors",
            }
            | (params_dict.get("convert_hex_rgba") or {}),
            method="call",
        ),
        "create_dn_meshgrid": Node(
            async_task=create_meshgrid.validate()
            .handle_errors(task_instance_id="create_dn_meshgrid")
            .set_executor("lithops"),
            partial={
                "intersecting_only": False,
                "crs": "EPSG:3857",
                "aoi": DependsOn("day_night_column"),
            }
            | (params_dict.get("create_dn_meshgrid") or {}),
            method="call",
        ),
        "persist_traj_df": Node(
            async_task=persist_df.validate()
            .handle_errors(task_instance_id="persist_traj_df")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("convert_hex_rgba"),
                "filetype": "gpkg",
                "root_path": DependsOn("create_output_directory"),
            }
            | (params_dict.get("persist_traj_df") or {}),
            method="call",
        ),
        "persist_relocs_df": Node(
            async_task=persist_df.validate()
            .handle_errors(task_instance_id="persist_relocs_df")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("day_night_column"),
                "filetype": "gpkg",
                "root_path": DependsOn("create_output_directory"),
            }
            | (params_dict.get("persist_relocs_df") or {}),
            method="call",
        ),
        "assign_cols": Node(
            async_task=assign_column.validate()
            .handle_errors(task_instance_id="assign_cols")
            .set_executor("lithops"),
            partial={
                "column_name": "area_status",
                "value": "unprotected",
                "df": DependsOn("convert_hex_rgba"),
            }
            | (params_dict.get("assign_cols") or {}),
            method="call",
        ),
        "join_traj_landdx": Node(
            async_task=spatial_join.validate()
            .handle_errors(task_instance_id="join_traj_landdx")
            .set_executor("lithops"),
            partial={
                "how": "inner",
                "predicate": "intersects",
                "local_gdf": DependsOn("load_aoi"),
                "trajs_gdf": DependsOn("assign_cols"),
            }
            | (params_dict.get("join_traj_landdx") or {}),
            method="call",
        ),
        "assign_protected_values": Node(
            async_task=assign_value_by_index.validate()
            .handle_errors(task_instance_id="assign_protected_values")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("assign_cols"),
                "subset_df": DependsOn("join_traj_landdx"),
                "column_name": "area_status",
                "value": "protected",
            }
            | (params_dict.get("assign_protected_values") or {}),
            method="call",
        ),
        "view_joined_gdf": Node(
            async_task=view_df.validate()
            .handle_errors(task_instance_id="view_joined_gdf")
            .set_executor("lithops"),
            partial={
                "name": "joined_df",
                "gdf": DependsOn("assign_protected_values"),
            }
            | (params_dict.get("view_joined_gdf") or {}),
            method="call",
        ),
        "split_trajectories_by_group": Node(
            async_task=split_groups.validate()
            .handle_errors(task_instance_id="split_trajectories_by_group")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("assign_protected_values"),
                "groupers": DependsOn("configure_grouping_strategy"),
            }
            | (params_dict.get("split_trajectories_by_group") or {}),
            method="call",
        ),
        "split_relocations_by_group": Node(
            async_task=split_groups.validate()
            .handle_errors(task_instance_id="split_relocations_by_group")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("day_night_column"),
                "groupers": DependsOn("configure_grouping_strategy"),
            }
            | (params_dict.get("split_relocations_by_group") or {}),
            method="call",
        ),
        "generate_substyled_layers": Node(
            async_task=create_polyline_layer.validate()
            .handle_errors(task_instance_id="generate_substyled_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "color_column": "hex_colors",
                    "auto_highlight": True,
                    "pickable": True,
                    "get_width": 3.0,
                    "width_unit": "pixels",
                    "cap_rounded": True,
                    "opacity": 0.35,
                },
                "legend": {"label_column": "extra__name", "color_column": "extra__hex"},
                "tooltip_columns": ["extra__hex", "extra__name", "extra__sex"],
            }
            | (params_dict.get("generate_substyled_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "combine_substyled_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_substyled_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_substyled_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_substyled_layers"),
            },
        ),
        "draw_substyled_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_substyled_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Subject Tracks",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_substyled_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_substyled_layers"),
            },
        ),
        "persist_substyled_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_substyled_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_substyled_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_substyled_ecomaps"),
            },
        ),
        "create_substyled_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_substyled_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Combined subject tracks ecomap",
            }
            | (params_dict.get("create_substyled_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_substyled_urls"),
            },
        ),
        "merge_substyled_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_substyled_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_substyled_ecomap_widgets"),
            }
            | (params_dict.get("merge_substyled_widgets") or {}),
            method="call",
        ),
        "generate_etd": Node(
            async_task=calculate_elliptical_time_density.validate()
            .handle_errors(task_instance_id="generate_etd")
            .set_executor("lithops"),
            partial={
                "crs": "ESRI:53042",
                "percentiles": [50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
                "nodata_value": "nan",
                "band_count": 1,
            }
            | (params_dict.get("generate_etd") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["trajectory_gdf"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "td_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="td_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "percentile",
                "colormap": "RdYlGn",
                "output_column_name": "percentile_colormap",
            }
            | (params_dict.get("td_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("generate_etd"),
            },
        ),
        "generate_etd_ecomap_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_etd_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "percentile_colormap",
                    "opacity": 0.35,
                    "stroked": False,
                },
                "legend": {
                    "label_column": "percentile",
                    "color_column": "percentile_colormap",
                },
                "tooltip_columns": ["percentile"],
            }
            | (params_dict.get("generate_etd_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("td_colormap"),
            },
        ),
        "combine_landdx_hr_ecomap_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_landdx_hr_ecomap_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_landdx_hr_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_etd_ecomap_layers"),
            },
        ),
        "draw_hr_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_hr_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Home Range Metrics",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_hr_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_landdx_hr_ecomap_layers"),
            },
        ),
        "persist_hr_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_hr_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_hr_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_hr_ecomaps"),
            },
        ),
        "create_hr_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_hr_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Home range ecomap",
            }
            | (params_dict.get("create_hr_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_hr_ecomap_urls"),
            },
        ),
        "merge_hr_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_hr_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_hr_ecomap_widgets"),
            }
            | (params_dict.get("merge_hr_ecomap_widgets") or {}),
            method="call",
        ),
        "custom_hr": Node(
            async_task=filter_column_values.validate()
            .handle_errors(task_instance_id="custom_hr")
            .set_executor("lithops"),
            partial={
                "column": "percentile",
                "values": [99.0],
            }
            | (params_dict.get("custom_hr") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("generate_etd"),
            },
        ),
        "custom_td_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="custom_td_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "percentile",
                "colormap": ["#d2691e"],
                "output_column_name": "percentile_colormap",
            }
            | (params_dict.get("custom_td_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("custom_hr"),
            },
        ),
        "generate_cetd_ecomap_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_cetd_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "percentile_colormap",
                    "opacity": 0.35,
                    "stroked": False,
                },
                "legend": {
                    "label_column": "percentile",
                    "color_column": "percentile_colormap",
                },
                "tooltip_columns": ["percentile"],
            }
            | (params_dict.get("generate_cetd_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("custom_td_colormap"),
            },
        ),
        "combine_landdx_custom_hr_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_landdx_custom_hr_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_landdx_custom_hr_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_cetd_ecomap_layers"),
            },
        ),
        "draw_custom_hr_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_custom_hr_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Home Range Metrics",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_custom_hr_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_landdx_custom_hr_layers"),
            },
        ),
        "persist_custom_hr_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_custom_hr_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_custom_hr_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_custom_hr_ecomaps"),
            },
        ),
        "create_custom_hr_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_custom_hr_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "99th percentile home range ecomap",
            }
            | (params_dict.get("create_custom_hr_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_custom_hr_ecomap_urls"),
            },
        ),
        "merge_custom_hr_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_custom_hr_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_custom_hr_ecomap_widgets"),
            }
            | (params_dict.get("merge_custom_hr_ecomap_widgets") or {}),
            method="call",
        ),
        "generate_season_etd": Node(
            async_task=calculate_etd_by_groups.validate()
            .handle_errors(task_instance_id="generate_season_etd")
            .set_executor("lithops"),
            partial={
                "crs": "ESRI:53042",
                "percentiles": [50.0, 60.0, 70.0, 80.0, 90.0, 99.0],
                "nodata_value": "nan",
                "band_count": 1,
                "include_groups": True,
                "groupby_cols": ["season"],
            }
            | (params_dict.get("generate_season_etd") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["trajectory_gdf"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "sort_season_etd_color": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_season_etd_color")
            .set_executor("lithops"),
            partial={
                "column_name": "season",
                "ascending": False,
                "na_position": "last",
            }
            | (params_dict.get("sort_season_etd_color") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("generate_season_etd"),
            },
        ),
        "apply_season_etd_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_season_etd_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "season",
                "colormap": ["#483d8b", "#deb887"],
                "output_column_name": "season_colormap",
            }
            | (params_dict.get("apply_season_etd_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_season_etd_color"),
            },
        ),
        "generate_season_ecomap_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_season_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "season_colormap",
                    "opacity": 0.35,
                    "stroked": False,
                },
                "legend": {"label_column": "season", "color_column": "season_colormap"},
                "tooltip_columns": ["season"],
            }
            | (params_dict.get("generate_season_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_season_etd_colormap"),
            },
        ),
        "combine_landdx_season_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_landdx_season_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_landdx_season_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_season_ecomap_layers"),
            },
        ),
        "draw_season_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_season_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right", "title": "Seasons"},
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_season_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_landdx_season_layers"),
            },
        ),
        "persist_season_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_season_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_season_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_season_ecomaps"),
            },
        ),
        "create_season_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_season_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Seasonal ecomap",
            }
            | (params_dict.get("create_season_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_season_ecomap_urls"),
            },
        ),
        "merge_season_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_season_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_season_ecomap_widgets"),
            }
            | (params_dict.get("merge_season_ecomap_widgets") or {}),
            method="call",
        ),
        "time_dominance": Node(
            async_task=compute_fix_density_and_night_class.validate()
            .handle_errors(task_instance_id="time_dominance")
            .set_executor("lithops"),
            partial={
                "mode": "dominance",
                "grid": DependsOn("create_dn_meshgrid"),
                "geometry_type": "point",
            }
            | (params_dict.get("time_dominance") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["selection"],
                "argvalues": DependsOn("split_relocations_by_group"),
            },
        ),
        "filter_dominance_values": Node(
            async_task=filter_time_dominance.validate()
            .handle_errors(task_instance_id="filter_dominance_values")
            .set_executor("lithops"),
            partial={
                "valid_dominance": ["day", "night"],
            }
            | (params_dict.get("filter_dominance_values") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("time_dominance"),
            },
        ),
        "sort_dominance_values": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_dominance_values")
            .set_executor("lithops"),
            partial={
                "column_name": "time_dominance",
                "ascending": False,
                "na_position": "last",
            }
            | (params_dict.get("sort_dominance_values") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("filter_dominance_values"),
            },
        ),
        "apply_dn_dom_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_dn_dom_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "time_dominance",
                "colormap": ["#a52a2a", "#ffd700"],
                "output_column_name": "time_dominance_colormap",
            }
            | (params_dict.get("apply_dn_dom_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_dominance_values"),
            },
        ),
        "generate_td_ecomap_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_td_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "time_dominance_colormap",
                    "opacity": 0.35,
                    "stroked": True,
                },
                "legend": {
                    "label_column": "time_dominance",
                    "color_column": "time_dominance_colormap",
                },
                "tooltip_columns": ["density", "time_dominance"],
            }
            | (params_dict.get("generate_td_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_dn_dom_colormap"),
            },
        ),
        "combine_landdx_td_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_landdx_td_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_landdx_td_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_td_ecomap_layers"),
            },
        ),
        "draw_tdominance_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_tdominance_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Time of Day Dominance",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_tdominance_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_landdx_td_layers"),
            },
        ),
        "persist_tdominance_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_tdominance_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_tdominance_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_tdominance_ecomaps"),
            },
        ),
        "create_tdom_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_tdom_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Night day raster",
            }
            | (params_dict.get("create_tdom_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_tdominance_ecomap_urls"),
            },
        ),
        "merge_td_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_td_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_tdom_ecomap_widgets"),
            }
            | (params_dict.get("merge_td_ecomap_widgets") or {}),
            method="call",
        ),
        "night_proportion_fixes": Node(
            async_task=compute_fix_density_and_night_class.validate()
            .handle_errors(task_instance_id="night_proportion_fixes")
            .set_executor("lithops"),
            partial={
                "mode": "proportion",
                "grid": DependsOn("create_dn_meshgrid"),
                "geometry_type": "point",
                "threshold": 0.65,
            }
            | (params_dict.get("night_proportion_fixes") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["selection"],
                "argvalues": DependsOn("split_relocations_by_group"),
            },
        ),
        "sort_night_proportion_values": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_night_proportion_values")
            .set_executor("lithops"),
            partial={
                "column_name": "night_class",
                "ascending": False,
                "na_position": "last",
            }
            | (params_dict.get("sort_night_proportion_values") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("night_proportion_fixes"),
            },
        ),
        "drop_nan_proportion_values": Node(
            async_task=drop_nan_values_by_column.validate()
            .handle_errors(task_instance_id="drop_nan_proportion_values")
            .set_executor("lithops"),
            partial={
                "column_name": "density",
            }
            | (params_dict.get("drop_nan_proportion_values") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_night_proportion_values"),
            },
        ),
        "drop_nan_threshold_values": Node(
            async_task=drop_missing_values_by_column.validate()
            .handle_errors(task_instance_id="drop_nan_threshold_values")
            .set_executor("lithops"),
            partial={
                "column_name": "night_class",
            }
            | (params_dict.get("drop_nan_threshold_values") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("drop_nan_proportion_values"),
            },
        ),
        "apply_nightpr_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_nightpr_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "night_class",
                "colormap": ["#6495ed", "#00008b"],
                "output_column_name": "night_class_colormap",
            }
            | (params_dict.get("apply_nightpr_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("drop_nan_threshold_values"),
            },
        ),
        "generate_nightpr_ecomap_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_nightpr_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "night_class_colormap",
                    "opacity": 0.35,
                    "stroked": True,
                },
                "legend": {
                    "label_column": "night_class",
                    "color_column": "night_class_colormap",
                },
                "tooltip_columns": ["density", "night_class", "night_class_colormap"],
            }
            | (params_dict.get("generate_nightpr_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_nightpr_colormap"),
            },
        ),
        "combine_landdx_np_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_landdx_np_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_landdx_np_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_nightpr_ecomap_layers"),
            },
        ),
        "draw_nightpr_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_nightpr_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Night Time Fixes",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_nightpr_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_landdx_np_layers"),
            },
        ),
        "persist_nightpr_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_nightpr_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_nightpr_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_nightpr_ecomaps"),
            },
        ),
        "create_nightpr_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_nightpr_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Proportion of night time fixes",
            }
            | (params_dict.get("create_nightpr_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_nightpr_ecomap_urls"),
            },
        ),
        "merge_npr_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_npr_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_nightpr_ecomap_widgets"),
            }
            | (params_dict.get("merge_npr_ecomap_widgets") or {}),
            method="call",
        ),
        "filter_dry_trajs": Node(
            async_task=filter_column_values.validate()
            .handle_errors(task_instance_id="filter_dry_trajs")
            .set_executor("lithops"),
            partial={
                "column": "season",
                "values": ["dry"],
            }
            | (params_dict.get("filter_dry_trajs") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "generate_dry_speed_rasters": Node(
            async_task=generate_ecograph_raster.validate()
            .handle_errors(task_instance_id="generate_dry_speed_rasters")
            .set_executor("lithops"),
            partial={
                "dist_col": "dist_meters",
                "output_dir": DependsOn("create_output_directory"),
                "interpolation": "mean",
                "movement_covariate": "speed",
            }
            | (params_dict.get("generate_dry_speed_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("filter_dry_trajs"),
            },
        ),
        "extract_dry_speed_rasters": Node(
            async_task=retrieve_feature_gdf.validate()
            .handle_errors(task_instance_id="extract_dry_speed_rasters")
            .set_executor("lithops"),
            partial=(params_dict.get("extract_dry_speed_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["file_path"],
                "argvalues": DependsOn("generate_dry_speed_rasters"),
            },
        ),
        "sort_dry_speed_features": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_dry_speed_features")
            .set_executor("lithops"),
            partial={
                "column_name": "value",
                "na_position": "last",
            }
            | (params_dict.get("sort_dry_speed_features") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("extract_dry_speed_rasters"),
            },
        ),
        "classify_dry_speed_features": Node(
            async_task=apply_classification.validate()
            .handle_errors(task_instance_id="classify_dry_speed_features")
            .set_executor("lithops"),
            partial={
                "input_column_name": "value",
                "output_column_name": "bins",
                "classification_options": {"scheme": "natural_breaks", "k": 6},
                "label_options": {"label_ranges": False, "label_decimals": 1},
            }
            | (params_dict.get("classify_dry_speed_features") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_dry_speed_features"),
            },
        ),
        "apply_dry_speed_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_dry_speed_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "speedraster_bins_colors",
                "colormap": [
                    "#1a9850",
                    "#91cf60",
                    "#d9ef8b",
                    "#fee08b",
                    "#fc8d59",
                    "#d73027",
                ],
            }
            | (params_dict.get("apply_dry_speed_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("classify_dry_speed_features"),
            },
        ),
        "format_dry_raster_labels": Node(
            async_task=map_values_with_unit.validate()
            .handle_errors(task_instance_id="format_dry_raster_labels")
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "bins_formatted",
                "original_unit": "km/h",
                "new_unit": "km/h",
                "decimal_places": 1,
            }
            | (params_dict.get("format_dry_raster_labels") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("apply_dry_speed_colormap"),
            },
        ),
        "generate_dry_raster_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_dry_raster_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "speedraster_bins_colors",
                    "opacity": 0.35,
                    "stroked": True,
                },
                "legend": {
                    "label_column": "bins_formatted",
                    "color_column": "speedraster_bins_colors",
                },
                "tooltip_columns": ["value", "bins", "speedraster_bins_colors"],
            }
            | (params_dict.get("generate_dry_raster_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("format_dry_raster_labels"),
            },
        ),
        "combine_dry_seasonal_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_dry_seasonal_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_dry_seasonal_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_dry_raster_layers"),
            },
        ),
        "draw_dry_speed_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_dry_speed_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Raster Value(Km/h)",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_dry_speed_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_dry_seasonal_layers"),
            },
        ),
        "dry_raster_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="dry_raster_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("dry_raster_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_dry_speed_ecomaps"),
            },
        ),
        "dry_single_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="dry_single_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Dry Speed Raster Ecomap",
            }
            | (params_dict.get("dry_single_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("dry_raster_ecomap_urls"),
            },
        ),
        "dry_raster_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="dry_raster_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("dry_single_ecomap_widgets"),
            }
            | (params_dict.get("dry_raster_ecomap_widgets") or {}),
            method="call",
        ),
        "filter_wet_trajs": Node(
            async_task=filter_column_values.validate()
            .handle_errors(task_instance_id="filter_wet_trajs")
            .set_executor("lithops"),
            partial={
                "column": "season",
                "values": ["wet"],
            }
            | (params_dict.get("filter_wet_trajs") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "generate_wet_speed_rasters": Node(
            async_task=generate_ecograph_raster.validate()
            .handle_errors(task_instance_id="generate_wet_speed_rasters")
            .set_executor("lithops"),
            partial={
                "dist_col": "dist_meters",
                "output_dir": DependsOn("create_output_directory"),
                "interpolation": "mean",
                "movement_covariate": "speed",
            }
            | (params_dict.get("generate_wet_speed_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("filter_wet_trajs"),
            },
        ),
        "extract_wet_speed_rasters": Node(
            async_task=retrieve_feature_gdf.validate()
            .handle_errors(task_instance_id="extract_wet_speed_rasters")
            .set_executor("lithops"),
            partial=(params_dict.get("extract_wet_speed_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["file_path"],
                "argvalues": DependsOn("generate_wet_speed_rasters"),
            },
        ),
        "sort_wet_speed_features": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_wet_speed_features")
            .set_executor("lithops"),
            partial={
                "column_name": "value",
                "na_position": "last",
            }
            | (params_dict.get("sort_wet_speed_features") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("extract_wet_speed_rasters"),
            },
        ),
        "classify_wet_speed_features": Node(
            async_task=apply_classification.validate()
            .handle_errors(task_instance_id="classify_wet_speed_features")
            .set_executor("lithops"),
            partial={
                "input_column_name": "value",
                "output_column_name": "bins",
                "classification_options": {"scheme": "natural_breaks", "k": 6},
                "label_options": {"label_ranges": False, "label_decimals": 1},
            }
            | (params_dict.get("classify_wet_speed_features") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_wet_speed_features"),
            },
        ),
        "apply_wet_speed_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_wet_speed_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "speedraster_bins_colors",
                "colormap": [
                    "#1a9850",
                    "#91cf60",
                    "#d9ef8b",
                    "#fee08b",
                    "#fc8d59",
                    "#d73027",
                ],
            }
            | (params_dict.get("apply_wet_speed_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("classify_wet_speed_features"),
            },
        ),
        "format_wet_raster_labels": Node(
            async_task=map_values_with_unit.validate()
            .handle_errors(task_instance_id="format_wet_raster_labels")
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "bins_formatted",
                "original_unit": "km/h",
                "new_unit": "km/h",
                "decimal_places": 1,
            }
            | (params_dict.get("format_wet_raster_labels") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("apply_wet_speed_colormap"),
            },
        ),
        "generate_wet_raster_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_wet_raster_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "speedraster_bins_colors",
                    "opacity": 0.35,
                    "stroked": True,
                },
                "legend": {
                    "label_column": "bins_formatted",
                    "color_column": "speedraster_bins_colors",
                },
                "tooltip_columns": ["value", "bins", "speedraster_bins_colors"],
            }
            | (params_dict.get("generate_wet_raster_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("format_wet_raster_labels"),
            },
        ),
        "combine_wet_seasonal_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_wet_seasonal_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_wet_seasonal_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_wet_raster_layers"),
            },
        ),
        "draw_wet_speed_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_wet_speed_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Raster Value(Km/h)",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_wet_speed_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_wet_seasonal_layers"),
            },
        ),
        "wet_raster_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="wet_raster_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("wet_raster_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_wet_speed_ecomaps"),
            },
        ),
        "wet_single_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="wet_single_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Wet Speed Raster Ecomap",
            }
            | (params_dict.get("wet_single_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("wet_raster_ecomap_urls"),
            },
        ),
        "wet_raster_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="wet_raster_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("wet_single_ecomap_widgets"),
            }
            | (params_dict.get("wet_raster_ecomap_widgets") or {}),
            method="call",
        ),
        "generate_recursion_rasters": Node(
            async_task=generate_ecograph_raster.validate()
            .handle_errors(task_instance_id="generate_recursion_rasters")
            .set_executor("lithops"),
            partial={
                "dist_col": "dist_meters",
                "output_dir": DependsOn("create_output_directory"),
                "interpolation": "mean",
                "network_metric": "weight",
            }
            | (params_dict.get("generate_recursion_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "extract_recursion_rasters": Node(
            async_task=retrieve_feature_gdf.validate()
            .handle_errors(task_instance_id="extract_recursion_rasters")
            .set_executor("lithops"),
            partial=(params_dict.get("extract_recursion_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["file_path"],
                "argvalues": DependsOn("generate_recursion_rasters"),
            },
        ),
        "sort_recursion_features": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_recursion_features")
            .set_executor("lithops"),
            partial={
                "column_name": "value",
                "na_position": "last",
            }
            | (params_dict.get("sort_recursion_features") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("extract_recursion_rasters"),
            },
        ),
        "classify_recursion_features": Node(
            async_task=apply_classification.validate()
            .handle_errors(task_instance_id="classify_recursion_features")
            .set_executor("lithops"),
            partial={
                "input_column_name": "value",
                "output_column_name": "bins",
                "classification_options": {"scheme": "natural_breaks", "k": 6},
                "label_options": {"label_ranges": False, "label_decimals": 1},
            }
            | (params_dict.get("classify_recursion_features") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_recursion_features"),
            },
        ),
        "apply_recursion_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_recursion_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "recursion_bins_colors",
                "colormap": [
                    "#1a9850",
                    "#91cf60",
                    "#d9ef8b",
                    "#fee08b",
                    "#fc8d59",
                    "#d73027",
                ],
            }
            | (params_dict.get("apply_recursion_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("classify_recursion_features"),
            },
        ),
        "generate_recursion_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_recursion_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "recursion_bins_colors",
                    "opacity": 0.35,
                    "stroked": True,
                },
                "legend": {
                    "label_column": "bins",
                    "color_column": "recursion_bins_colors",
                },
                "tooltip_columns": ["value", "bins", "recursion_bins_colors"],
            }
            | (params_dict.get("generate_recursion_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_recursion_colormap"),
            },
        ),
        "combine_recursion_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_recursion_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_recursion_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_recursion_layers"),
            },
        ),
        "draw_recursion_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_recursion_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Recursion Events",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_recursion_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_recursion_layers"),
            },
        ),
        "recursion_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="recursion_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("recursion_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_recursion_ecomaps"),
            },
        ),
        "recursion_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="recursion_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Recursion Events Raster Ecomap",
            }
            | (params_dict.get("recursion_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("recursion_ecomap_urls"),
            },
        ),
        "reraster_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="reraster_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("recursion_ecomap_widgets"),
            }
            | (params_dict.get("reraster_ecomap_widgets") or {}),
            method="call",
        ),
        "filter_protected_trajs": Node(
            async_task=filter_column_values.validate()
            .handle_errors(task_instance_id="filter_protected_trajs")
            .set_executor("lithops"),
            partial={
                "column": "area_status",
                "values": ["protected"],
            }
            | (params_dict.get("filter_protected_trajs") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "generate_protected_etd": Node(
            async_task=calculate_elliptical_time_density.validate()
            .handle_errors(task_instance_id="generate_protected_etd")
            .set_executor("lithops"),
            partial={
                "crs": "ESRI:53042",
                "percentiles": [50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
                "nodata_value": "nan",
                "band_count": 1,
            }
            | (params_dict.get("generate_protected_etd") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["trajectory_gdf"],
                "argvalues": DependsOn("filter_protected_trajs"),
            },
        ),
        "td_protected_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="td_protected_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "percentile",
                "colormap": "RdYlGn",
                "output_column_name": "percentile_colormap",
            }
            | (params_dict.get("td_protected_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("generate_protected_etd"),
            },
        ),
        "generate_etd_protected_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_etd_protected_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "percentile_colormap",
                    "opacity": 0.35,
                    "stroked": False,
                },
                "legend": {
                    "label_column": "percentile",
                    "color_column": "percentile_colormap",
                },
                "tooltip_columns": ["percentile"],
            }
            | (params_dict.get("generate_etd_protected_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("td_protected_colormap"),
            },
        ),
        "combine_ldx_protected_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_ldx_protected_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_ldx_protected_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_etd_protected_layers"),
            },
        ),
        "draw_protected_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_protected_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Home Range Metrics",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_protected_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_ldx_protected_layers"),
            },
        ),
        "persist_protected_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_protected_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_protected_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_protected_ecomaps"),
            },
        ),
        "create_protected_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_protected_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Protected home range ecomap",
            }
            | (params_dict.get("create_protected_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_protected_urls"),
            },
        ),
        "merge_protected_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_protected_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_protected_widgets"),
            }
            | (params_dict.get("merge_protected_widgets") or {}),
            method="call",
        ),
        "filter_unprotected_trajs": Node(
            async_task=filter_column_values.validate()
            .handle_errors(task_instance_id="filter_unprotected_trajs")
            .set_executor("lithops"),
            partial={
                "column": "area_status",
                "values": ["unprotected"],
            }
            | (params_dict.get("filter_unprotected_trajs") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "generate_unprotected_etd": Node(
            async_task=calculate_elliptical_time_density.validate()
            .handle_errors(task_instance_id="generate_unprotected_etd")
            .set_executor("lithops"),
            partial={
                "crs": "ESRI:53042",
                "percentiles": [50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
                "nodata_value": "nan",
                "band_count": 1,
            }
            | (params_dict.get("generate_unprotected_etd") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["trajectory_gdf"],
                "argvalues": DependsOn("filter_unprotected_trajs"),
            },
        ),
        "td_unprotected_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="td_unprotected_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "percentile",
                "colormap": "RdYlGn",
                "output_column_name": "percentile_colormap",
            }
            | (params_dict.get("td_unprotected_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("generate_unprotected_etd"),
            },
        ),
        "generate_unprotected_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_unprotected_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "percentile_colormap",
                    "opacity": 0.35,
                    "stroked": False,
                },
                "legend": {
                    "label_column": "percentile",
                    "color_column": "percentile_colormap",
                },
                "tooltip_columns": ["percentile"],
            }
            | (params_dict.get("generate_unprotected_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("td_unprotected_colormap"),
            },
        ),
        "combine_ldx_unprotected_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_ldx_unprotected_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_ldx_unprotected_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_unprotected_layers"),
            },
        ),
        "draw_unprotected_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_unprotected_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Home Range Metrics",
                },
                "static": False,
                "title": None,
                "max_zoom": 20,
            }
            | (params_dict.get("draw_unprotected_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_ldx_unprotected_layers"),
            },
        ),
        "persist_unprotected_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_unprotected_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_unprotected_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_unprotected_ecomaps"),
            },
        ),
        "create_unprotected_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_unprotected_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Unprotected home range ecomap",
            }
            | (params_dict.get("create_unprotected_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_unprotected_urls"),
            },
        ),
        "merge_unprotected_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_unprotected_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_unprotected_widgets"),
            }
            | (params_dict.get("merge_unprotected_widgets") or {}),
            method="call",
        ),
        "unpr_category_summary": Node(
            async_task=category_summary.validate()
            .handle_errors(task_instance_id="unpr_category_summary")
            .set_executor("lithops"),
            partial={
                "group_cols": ["extra__name", "season"],
                "category_col": "area_status",
                "pct_for": ["protected", "unprotected"],
            }
            | (params_dict.get("unpr_category_summary") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "plot_prot_unprot": Node(
            async_task=plot_protected_fix_proportions.validate()
            .handle_errors(task_instance_id="plot_prot_unprot")
            .set_executor("lithops"),
            partial={
                "title": "proportion",
            }
            | (params_dict.get("plot_prot_unprot") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["summary"],
                "argvalues": DependsOn("unpr_category_summary"),
            },
        ),
        "persist_pr_chart": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_pr_chart")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_pr_chart") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("plot_prot_unprot"),
            },
        ),
        "create_single_prot_widget": Node(
            async_task=create_plot_widget_single_view.validate()
            .handle_errors(task_instance_id="create_single_prot_widget")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Proportion of Fixes",
            }
            | (params_dict.get("create_single_prot_widget") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_pr_chart"),
            },
        ),
        "merge_prot_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_prot_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_single_prot_widget"),
            }
            | (params_dict.get("merge_prot_widgets") or {}),
            method="call",
        ),
        "view_prot_df": Node(
            async_task=view_df.validate()
            .handle_errors(task_instance_id="view_prot_df")
            .set_executor("lithops"),
            partial={
                "name": "summary-table-df",
            }
            | (params_dict.get("view_prot_df") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("unpr_category_summary"),
            },
        ),
        "mapbook_dashboard": Node(
            async_task=gather_dashboard.validate()
            .handle_errors(task_instance_id="mapbook_dashboard")
            .set_executor("lithops"),
            partial={
                "details": DependsOn("initialize_workflow_metadata"),
                "widgets": DependsOnSequence(
                    [
                        DependsOn("merge_substyled_widgets"),
                        DependsOn("merge_hr_ecomap_widgets"),
                        DependsOn("merge_custom_hr_ecomap_widgets"),
                        DependsOn("merge_season_ecomap_widgets"),
                        DependsOn("merge_td_ecomap_widgets"),
                        DependsOn("merge_npr_ecomap_widgets"),
                        DependsOn("dry_raster_ecomap_widgets"),
                        DependsOn("wet_raster_ecomap_widgets"),
                        DependsOn("reraster_ecomap_widgets"),
                        DependsOn("merge_protected_widgets"),
                        DependsOn("merge_unprotected_widgets"),
                        DependsOn("merge_prot_widgets"),
                    ],
                ),
                "time_range": DependsOn("define_time_range"),
                "groupers": DependsOn("configure_grouping_strategy"),
            }
            | (params_dict.get("mapbook_dashboard") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
