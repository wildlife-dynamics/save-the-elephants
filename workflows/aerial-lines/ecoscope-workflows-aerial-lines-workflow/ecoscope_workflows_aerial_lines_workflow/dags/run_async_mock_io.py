# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details

# ruff: noqa: E402

"""WARNING: This file is generated in a testing context and should not be used in production.
Lines specific to the testing context are marked with a test tube emoji (ðŸ§ª) to indicate
that they would not be included (or would be different) in the production version of this file.
"""

import json
import os
import warnings  # ðŸ§ª

from ecoscope_workflows_core.graph import DependsOn, DependsOnSequence, Graph, Node
from ecoscope_workflows_core.tasks.analysis import (
    apply_arithmetic_operation as apply_arithmetic_operation,
)
from ecoscope_workflows_core.tasks.config import (
    set_workflow_details as set_workflow_details,
)
from ecoscope_workflows_core.tasks.filter import set_time_range as set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers as set_groupers
from ecoscope_workflows_core.tasks.results import (
    create_single_value_widget_single_view as create_single_value_widget_single_view,
)
from ecoscope_workflows_core.tasks.results import gather_dashboard as gather_dashboard
from ecoscope_workflows_core.testing import create_task_magicmock  # ðŸ§ª
from ecoscope_workflows_ext_ste.tasks import add_two_thousand as add_two_thousand

from ..params import Params


def main(params: Params):
    warnings.warn("This test script should not be used in production!")  # ðŸ§ª

    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "workflow_details": [],
        "time_range": [],
        "groupers": [],
        "calculator": [],
        "add_more": ["calculator"],
        "sv_widgets": ["add_more"],
        "template_dashboard": [
            "workflow_details",
            "sv_widgets",
            "time_range",
            "groupers",
        ],
    }

    nodes = {
        "workflow_details": Node(
            async_task=set_workflow_details.validate()
            .set_task_instance_id("workflow_details")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial=(params_dict.get("workflow_details") or {}),
            method="call",
        ),
        "time_range": Node(
            async_task=set_time_range.validate()
            .set_task_instance_id("time_range")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "time_format": "%d %b %Y %H:%M:%S %Z",
            }
            | (params_dict.get("time_range") or {}),
            method="call",
        ),
        "groupers": Node(
            async_task=set_groupers.validate()
            .set_task_instance_id("groupers")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial=(params_dict.get("groupers") or {}),
            method="call",
        ),
        "calculator": Node(
            async_task=apply_arithmetic_operation.validate()
            .set_task_instance_id("calculator")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial=(params_dict.get("calculator") or {}),
            method="call",
        ),
        "add_more": Node(
            async_task=add_two_thousand.validate()
            .set_task_instance_id("add_more")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "value": DependsOn("calculator"),
            }
            | (params_dict.get("add_more") or {}),
            method="call",
        ),
        "sv_widgets": Node(
            async_task=create_single_value_widget_single_view.validate()
            .set_task_instance_id("sv_widgets")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "title": "Sum",
                "decimal_places": 0,
                "data": DependsOn("add_more"),
            }
            | (params_dict.get("sv_widgets") or {}),
            method="call",
        ),
        "template_dashboard": Node(
            async_task=gather_dashboard.validate()
            .set_task_instance_id("template_dashboard")
            .handle_errors()
            .with_tracing()
            .set_executor("lithops"),
            partial={
                "details": DependsOn("workflow_details"),
                "widgets": DependsOn("sv_widgets"),
                "time_range": DependsOn("time_range"),
                "groupers": DependsOn("groupers"),
            }
            | (params_dict.get("template_dashboard") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
