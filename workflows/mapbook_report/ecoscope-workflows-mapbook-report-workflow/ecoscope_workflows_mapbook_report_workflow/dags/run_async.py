# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details
import json
import os

from ecoscope_workflows_core.graph import DependsOn, DependsOnSequence, Graph, Node
from ecoscope_workflows_core.tasks.analysis import (
    dataframe_column_nunique as dataframe_column_nunique,
)
from ecoscope_workflows_core.tasks.analysis import (
    dataframe_column_sum as dataframe_column_sum,
)
from ecoscope_workflows_core.tasks.config import (
    set_workflow_details as set_workflow_details,
)
from ecoscope_workflows_core.tasks.filter import set_time_range as set_time_range
from ecoscope_workflows_core.tasks.groupby import groupbykey as groupbykey
from ecoscope_workflows_core.tasks.groupby import set_groupers as set_groupers
from ecoscope_workflows_core.tasks.groupby import split_groups as split_groups
from ecoscope_workflows_core.tasks.io import persist_text as persist_text
from ecoscope_workflows_core.tasks.io import set_er_connection as set_er_connection
from ecoscope_workflows_core.tasks.io import set_gee_connection as set_gee_connection
from ecoscope_workflows_core.tasks.results import (
    create_map_widget_single_view as create_map_widget_single_view,
)
from ecoscope_workflows_core.tasks.results import (
    create_single_value_widget_single_view as create_single_value_widget_single_view,
)
from ecoscope_workflows_core.tasks.results import (
    create_text_widget_single_view as create_text_widget_single_view,
)
from ecoscope_workflows_core.tasks.results import gather_dashboard as gather_dashboard
from ecoscope_workflows_core.tasks.results import (
    merge_widget_views as merge_widget_views,
)
from ecoscope_workflows_core.tasks.skip import (
    any_dependency_skipped as any_dependency_skipped,
)
from ecoscope_workflows_core.tasks.skip import any_is_empty_df as any_is_empty_df
from ecoscope_workflows_core.tasks.skip import never as never
from ecoscope_workflows_core.tasks.transformation import (
    add_temporal_index as add_temporal_index,
)
from ecoscope_workflows_core.tasks.transformation import map_columns as map_columns
from ecoscope_workflows_core.tasks.transformation import (
    map_values_with_unit as map_values_with_unit,
)
from ecoscope_workflows_core.tasks.transformation import sort_values as sort_values
from ecoscope_workflows_ext_custom.tasks.io import html_to_png as html_to_png
from ecoscope_workflows_ext_custom.tasks.io import load_df as load_df
from ecoscope_workflows_ext_custom.tasks.transformation import (
    filter_row_values as filter_row_values,
)
from ecoscope_workflows_ext_ecoscope.tasks.analysis import (
    calculate_elliptical_time_density as calculate_elliptical_time_density,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import (
    determine_season_windows as determine_season_windows,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import (
    get_subjectgroup_observations as get_subjectgroup_observations,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df as persist_df
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import (
    process_relocations as process_relocations,
)
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import (
    relocations_to_trajectory as relocations_to_trajectory,
)
from ecoscope_workflows_ext_ecoscope.tasks.results import (
    create_polygon_layer as create_polygon_layer,
)
from ecoscope_workflows_ext_ecoscope.tasks.results import (
    create_polyline_layer as create_polyline_layer,
)
from ecoscope_workflows_ext_ecoscope.tasks.results import draw_ecomap as draw_ecomap
from ecoscope_workflows_ext_ecoscope.tasks.results import set_base_maps as set_base_maps
from ecoscope_workflows_ext_ecoscope.tasks.skip import (
    all_geometry_are_none as all_geometry_are_none,
)
from ecoscope_workflows_ext_ecoscope.tasks.transformation import (
    apply_classification as apply_classification,
)
from ecoscope_workflows_ext_ecoscope.tasks.transformation import (
    apply_color_map as apply_color_map,
)
from ecoscope_workflows_ext_ecoscope.tasks.transformation import (
    classify_is_night as classify_is_night,
)
from ecoscope_workflows_ext_ste.tasks import (
    annotate_gdf_dict_with_geom_type as annotate_gdf_dict_with_geom_type,
)
from ecoscope_workflows_ext_ste.tasks import (
    build_mapbook_report_template as build_mapbook_report_template,
)
from ecoscope_workflows_ext_ste.tasks import (
    calculate_seasonal_home_range as calculate_seasonal_home_range,
)
from ecoscope_workflows_ext_ste.tasks import combine_map_layers as combine_map_layers
from ecoscope_workflows_ext_ste.tasks import create_context_page as create_context_page
from ecoscope_workflows_ext_ste.tasks import (
    create_layers_from_gdf_dict as create_layers_from_gdf_dict,
)
from ecoscope_workflows_ext_ste.tasks import (
    create_mapbook_context as create_mapbook_context,
)
from ecoscope_workflows_ext_ste.tasks import (
    create_report_context_from_tuple as create_report_context_from_tuple,
)
from ecoscope_workflows_ext_ste.tasks import (
    create_seasonal_labels as create_seasonal_labels,
)
from ecoscope_workflows_ext_ste.tasks import (
    create_view_state_from_gdf as create_view_state_from_gdf,
)
from ecoscope_workflows_ext_ste.tasks import (
    dataframe_column_first_unique_str as dataframe_column_first_unique_str,
)
from ecoscope_workflows_ext_ste.tasks import (
    fetch_and_persist_file as fetch_and_persist_file,
)
from ecoscope_workflows_ext_ste.tasks import flatten_tuple as flatten_tuple
from ecoscope_workflows_ext_ste.tasks import (
    generate_ecograph_raster as generate_ecograph_raster,
)
from ecoscope_workflows_ext_ste.tasks import generate_mcp_gdf as generate_mcp_gdf
from ecoscope_workflows_ext_ste.tasks import get_duration as get_duration
from ecoscope_workflows_ext_ste.tasks import get_file_path as get_file_path
from ecoscope_workflows_ext_ste.tasks import (
    get_split_group_column as get_split_group_column,
)
from ecoscope_workflows_ext_ste.tasks import (
    get_split_group_names as get_split_group_names,
)
from ecoscope_workflows_ext_ste.tasks import (
    label_quarter_status as label_quarter_status,
)
from ecoscope_workflows_ext_ste.tasks import make_text_layer as make_text_layer
from ecoscope_workflows_ext_ste.tasks import merge_docx_files as merge_docx_files
from ecoscope_workflows_ext_ste.tasks import (
    modify_quarter_status_colors as modify_quarter_status_colors,
)
from ecoscope_workflows_ext_ste.tasks import (
    retrieve_feature_gdf as retrieve_feature_gdf,
)
from ecoscope_workflows_ext_ste.tasks import round_off_values as round_off_values
from ecoscope_workflows_ext_ste.tasks import split_gdf_by_column as split_gdf_by_column
from ecoscope_workflows_ext_ste.tasks import zip_lists as zip_lists

from ..params import Params


def main(params: Params):
    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "initialize_workflow_metadata": [],
        "time_range": [],
        "groupers": [],
        "configure_base_maps": [],
        "download_mapbook_cover_page": [],
        "download_sect_templates": [],
        "download_logo_path": [],
        "retrieve_ldx_db": [],
        "load_landdx": ["retrieve_ldx_db"],
        "filter_landdx_aoi": ["load_landdx"],
        "custom_text_layer": ["filter_landdx_aoi"],
        "split_landdx_by_type": ["filter_landdx_aoi"],
        "annotate_geometry_types": ["split_landdx_by_type"],
        "create_styled_landdx_layers": ["annotate_geometry_types"],
        "er_client_name": [],
        "gee_project_name": [],
        "subject_observations": ["er_client_name", "time_range"],
        "subject_reloc": ["subject_observations"],
        "annotate_day_night": ["subject_reloc"],
        "convert_to_trajectories": ["annotate_day_night"],
        "add_temporal_index_to_traj": ["convert_to_trajectories", "groupers"],
        "classify_trajectory_speed_bins": ["add_temporal_index_to_traj"],
        "label_trajectory_quarters": ["classify_trajectory_speed_bins"],
        "rename_traj_cols": ["label_trajectory_quarters"],
        "persist_trajectory_df": ["rename_traj_cols"],
        "persist_trajectory_gpq": ["rename_traj_cols"],
        "persist_relocs_df": ["annotate_day_night"],
        "persist_relocs_gpq": ["annotate_day_night"],
        "split_trajectories_by_group": ["rename_traj_cols", "groupers"],
        "split_group_column": ["split_trajectories_by_group"],
        "assign_quarter_colors_traj": [
            "split_group_column",
            "split_trajectories_by_group",
        ],
        "sort_trajectories_by_speed": ["assign_quarter_colors_traj"],
        "apply_speed_colormap": ["sort_trajectories_by_speed"],
        "format_speed_bin_labels": ["apply_speed_colormap"],
        "format_speed_values": ["format_speed_bin_labels"],
        "generate_speedmap_layers": ["format_speed_values"],
        "zoom_global_view": ["format_speed_values"],
        "ldx_speed_layers": [
            "create_styled_landdx_layers",
            "custom_text_layer",
            "generate_speedmap_layers",
        ],
        "zip_speed_zoom_values": ["ldx_speed_layers", "zoom_global_view"],
        "draw_speed_ecomap": ["configure_base_maps", "zip_speed_zoom_values"],
        "persist_speed_ecomap_urls": ["draw_speed_ecomap"],
        "create_speedmap_widgets": ["persist_speed_ecomap_urls"],
        "merge_speedmap_widgets": ["create_speedmap_widgets"],
        "sort_trajs_by_day_night": ["assign_quarter_colors_traj"],
        "apply_day_night_colormap": ["sort_trajs_by_day_night"],
        "generate_day_night_ecomap_layers": ["apply_day_night_colormap"],
        "ldx_dn_layers": [
            "create_styled_landdx_layers",
            "custom_text_layer",
            "generate_day_night_ecomap_layers",
        ],
        "zoom_day_night": ["ldx_dn_layers", "zoom_global_view"],
        "draw_day_night_ecomap": ["configure_base_maps", "zoom_day_night"],
        "persist_day_night_ecomap_urls": ["draw_day_night_ecomap"],
        "create_day_night_ecomap_widgets": ["persist_day_night_ecomap_urls"],
        "merge_day_night_ecomap_widgets": ["create_day_night_ecomap_widgets"],
        "sort_trajs_by_quarter_status": ["assign_quarter_colors_traj"],
        "generate_quarter_ecomap_layers": ["sort_trajs_by_quarter_status"],
        "combine_quarter_ecomap_layers": [
            "create_styled_landdx_layers",
            "custom_text_layer",
            "generate_quarter_ecomap_layers",
        ],
        "zoom_quarter_movements": ["combine_quarter_ecomap_layers", "zoom_global_view"],
        "draw_quarter_status_ecomap": ["configure_base_maps", "zoom_quarter_movements"],
        "persist_quarter_ecomap_urls": ["draw_quarter_status_ecomap"],
        "create_quarter_ecomap_widgets": ["persist_quarter_ecomap_urls"],
        "merge_quarter_ecomap_widgets": ["create_quarter_ecomap_widgets"],
        "generate_etd": ["assign_quarter_colors_traj"],
        "determine_seasonal_windows": [
            "gee_project_name",
            "time_range",
            "generate_etd",
        ],
        "zip_etd_and_grouped_trajs": [
            "determine_seasonal_windows",
            "assign_quarter_colors_traj",
        ],
        "add_season_labels": ["zip_etd_and_grouped_trajs"],
        "calculate_mcp": ["assign_quarter_colors_traj"],
        "apply_etd_percentile_colormap": ["generate_etd"],
        "generate_etd_ecomap_layers": ["apply_etd_percentile_colormap"],
        "generate_mcp_layers": ["calculate_mcp"],
        "zip_mcp_hr": ["generate_mcp_layers", "generate_etd_ecomap_layers"],
        "combine_landdx_hr_ecomap_layers": [
            "create_styled_landdx_layers",
            "custom_text_layer",
            "zip_mcp_hr",
        ],
        "hr_view_zip": ["combine_landdx_hr_ecomap_layers", "zoom_global_view"],
        "draw_hr_ecomap": ["configure_base_maps", "hr_view_zip"],
        "persist_hr_ecomap_urls": ["draw_hr_ecomap"],
        "create_hr_ecomap_widgets": ["persist_hr_ecomap_urls"],
        "merge_hr_ecomap_widgets": ["create_hr_ecomap_widgets"],
        "generate_speed_raster": ["assign_quarter_colors_traj"],
        "extract_speed_rasters": ["generate_speed_raster"],
        "sort_speed_features_by_value": ["extract_speed_rasters"],
        "classify_speed_features": ["sort_speed_features_by_value"],
        "apply_speed_raster_colormap": ["classify_speed_features"],
        "format_speed_raster_labels": ["apply_speed_raster_colormap"],
        "generate_raster_layers": ["format_speed_raster_labels"],
        "combine_seasonal_raster_layers": [
            "create_styled_landdx_layers",
            "custom_text_layer",
            "generate_raster_layers",
        ],
        "speedraster_view_zip": ["combine_seasonal_raster_layers", "zoom_global_view"],
        "draw_speed_raster_ecomaps": ["configure_base_maps", "speedraster_view_zip"],
        "speed_raster_ecomap_urls": ["draw_speed_raster_ecomaps"],
        "speed_raster_ecomap_widgets": ["speed_raster_ecomap_urls"],
        "speedraster_ecomap_widgets": ["speed_raster_ecomap_widgets"],
        "seasonal_home_range": ["add_season_labels"],
        "season_colormap": ["seasonal_home_range"],
        "season_etd_map_layer": ["season_colormap"],
        "comb_season_map_layers": [
            "create_styled_landdx_layers",
            "custom_text_layer",
            "season_etd_map_layer",
        ],
        "seasons_view_zip": ["comb_season_map_layers", "zoom_global_view"],
        "seasonal_ecomap": ["configure_base_maps", "seasons_view_zip"],
        "season_etd_ecomap_html_url": ["seasonal_ecomap"],
        "season_etd_widgets_single_view": ["season_etd_ecomap_html_url"],
        "season_grouped_map_widget": ["season_etd_widgets_single_view"],
        "total_mcp_area": ["calculate_mcp"],
        "round_mcp_area": ["total_mcp_area"],
        "total_grid_area": ["generate_etd"],
        "round_grid_area": ["total_grid_area"],
        "total_mcp_sv_widgets": ["round_mcp_area"],
        "total_mcp_grouped_sv_widget": ["total_mcp_sv_widgets"],
        "total_grid_sv_widgets": ["round_grid_area"],
        "total_grid_grouped_sv_widget": ["total_grid_sv_widgets"],
        "subject_gender": ["assign_quarter_colors_traj"],
        "gender_widgets": ["subject_gender"],
        "gender_sv_widget": ["gender_widgets"],
        "report_duration": ["time_range"],
        "round_report_duration": ["report_duration"],
        "get_subject_name": ["assign_quarter_colors_traj"],
        "unique_subjects": ["rename_traj_cols"],
        "create_cover_template_context": [
            "unique_subjects",
            "download_logo_path",
            "time_range",
        ],
        "persist_context_cover": [
            "download_mapbook_cover_page",
            "create_cover_template_context",
        ],
        "convert_speedmap_html_to_png": ["persist_speed_ecomap_urls"],
        "convert_day_night_html_to_png": ["persist_day_night_ecomap_urls"],
        "convert_quarter_html_to_png": ["persist_quarter_ecomap_urls"],
        "convert_hr_html_to_png": ["persist_hr_ecomap_urls"],
        "convert_speed_raster_html_to_png": ["speed_raster_ecomap_urls"],
        "convert_seasonal_hr_html_to_png": ["season_etd_ecomap_html_url"],
        "zip_mapbook_context": [
            "round_grid_area",
            "round_mcp_area",
            "convert_quarter_html_to_png",
            "convert_hr_html_to_png",
            "convert_speed_raster_html_to_png",
            "convert_day_night_html_to_png",
            "convert_speedmap_html_to_png",
            "convert_seasonal_hr_html_to_png",
            "get_subject_name",
        ],
        "flatten_mbook_context": ["zip_mapbook_context"],
        "get_grouper_names": ["split_trajectories_by_group"],
        "zip_grouper_with_context": ["get_grouper_names", "flatten_mbook_context"],
        "flatten_final_report_context": ["zip_grouper_with_context"],
        "prepare_mapbook_context": ["flatten_final_report_context"],
        "individual_mapbook_context": [
            "download_sect_templates",
            "time_range",
            "round_report_duration",
            "prepare_mapbook_context",
        ],
        "generate_mapbook_report": [
            "persist_context_cover",
            "individual_mapbook_context",
        ],
        "mapbook_dashboard": [
            "initialize_workflow_metadata",
            "gender_sv_widget",
            "total_mcp_grouped_sv_widget",
            "total_grid_grouped_sv_widget",
            "merge_quarter_ecomap_widgets",
            "merge_hr_ecomap_widgets",
            "merge_speedmap_widgets",
            "speedraster_ecomap_widgets",
            "merge_day_night_ecomap_widgets",
            "season_grouped_map_widget",
            "time_range",
            "groupers",
        ],
    }

    nodes = {
        "initialize_workflow_metadata": Node(
            async_task=set_workflow_details.validate()
            .set_task_instance_id("initialize_workflow_metadata")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("initialize_workflow_metadata") or {}),
            method="call",
        ),
        "time_range": Node(
            async_task=set_time_range.validate()
            .set_task_instance_id("time_range")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "time_format": "%d %b %Y %H:%M:%S %Z",
                "timezone": {
                    "label": "UTC",
                    "tzCode": "UTC",
                    "name": "UTC",
                    "utc_offset": "+00:00",
                },
            }
            | (params_dict.get("time_range") or {}),
            method="call",
        ),
        "groupers": Node(
            async_task=set_groupers.validate()
            .set_task_instance_id("groupers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("groupers") or {}),
            method="call",
        ),
        "configure_base_maps": Node(
            async_task=set_base_maps.validate()
            .set_task_instance_id("configure_base_maps")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("configure_base_maps") or {}),
            method="call",
        ),
        "download_mapbook_cover_page": Node(
            async_task=fetch_and_persist_file.validate()
            .set_task_instance_id("download_mapbook_cover_page")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "url": "https://www.dropbox.com/scl/fi/1373gi65ji918rxele5h9/cover_page_v3.docx?rlkey=ur01wtpa98tcyq8f0f6dtksl8&st=eq39sgwz&dl=0",
                "output_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "overwrite_existing": False,
                "unzip": False,
                "retries": 2,
            }
            | (params_dict.get("download_mapbook_cover_page") or {}),
            method="call",
        ),
        "download_sect_templates": Node(
            async_task=fetch_and_persist_file.validate()
            .set_task_instance_id("download_sect_templates")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "url": "https://www.dropbox.com/scl/fi/0as1u7uuhia7emp5cqxfl/mapbook_subject_template_v6.docx?rlkey=4nzn4qa2hu0v3fqo8bpki4tgu&st=kco28x6g&dl=0",
                "output_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "overwrite_existing": False,
                "unzip": False,
                "retries": 2,
            }
            | (params_dict.get("download_sect_templates") or {}),
            method="call",
        ),
        "download_logo_path": Node(
            async_task=fetch_and_persist_file.validate()
            .set_task_instance_id("download_logo_path")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "url": "https://www.dropbox.com/scl/fi/1gn84pq9c7tedgg3k90qt/save-the-elephants.jpg?rlkey=ump7g2hcc2pn0pd5nst203c7w&st=jlwbhik9&dl=0",
                "output_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "overwrite_existing": False,
                "unzip": False,
                "retries": 2,
            }
            | (params_dict.get("download_logo_path") or {}),
            method="call",
        ),
        "retrieve_ldx_db": Node(
            async_task=get_file_path.validate()
            .set_task_instance_id("retrieve_ldx_db")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("retrieve_ldx_db") or {}),
            method="call",
        ),
        "load_landdx": Node(
            async_task=load_df.validate()
            .set_task_instance_id("load_landdx")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "file_path": DependsOn("retrieve_ldx_db"),
                "layer": "landDx_polygons",
                "deserialize_json": False,
            }
            | (params_dict.get("load_landdx") or {}),
            method="call",
        ),
        "filter_landdx_aoi": Node(
            async_task=filter_row_values.validate()
            .set_task_instance_id("filter_landdx_aoi")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("load_landdx"),
                "column": "type",
                "values": [
                    "Community Conservancy",
                    "National Reserve",
                    "National Park",
                ],
            }
            | (params_dict.get("filter_landdx_aoi") or {}),
            method="call",
        ),
        "custom_text_layer": Node(
            async_task=make_text_layer.validate()
            .set_task_instance_id("custom_text_layer")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "txt_gdf": DependsOn("filter_landdx_aoi"),
                "label_column": "label",
                "name_column": "name",
                "use_centroid": True,
                "color": [0, 0, 0, 255],
                "size": 16,
                "font_weight": "normal",
                "font_family": "Arial",
                "text_anchor": "middle",
                "alignment_baseline": "center",
                "pickable": True,
                "tooltip_columns": None,
                "zoom": False,
                "target_crs": "epsg:4326",
            }
            | (params_dict.get("custom_text_layer") or {}),
            method="call",
        ),
        "split_landdx_by_type": Node(
            async_task=split_gdf_by_column.validate()
            .set_task_instance_id("split_landdx_by_type")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("filter_landdx_aoi"),
                "column": "type",
            }
            | (params_dict.get("split_landdx_by_type") or {}),
            method="call",
        ),
        "annotate_geometry_types": Node(
            async_task=annotate_gdf_dict_with_geom_type.validate()
            .set_task_instance_id("annotate_geometry_types")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf_dict": DependsOn("split_landdx_by_type"),
            }
            | (params_dict.get("annotate_geometry_types") or {}),
            method="call",
        ),
        "create_styled_landdx_layers": Node(
            async_task=create_layers_from_gdf_dict.validate()
            .set_task_instance_id("create_styled_landdx_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf_dict": DependsOn("annotate_geometry_types"),
                "styles": {
                    "Community Conservancy": {
                        "get_fill_color": [85, 107, 47],
                        "get_line_color": [85, 107, 47],
                        "opacity": 0.15,
                        "stroked": True,
                        "get_line_width": 1.55,
                    },
                    "National Reserve": {
                        "get_fill_color": [143, 188, 139],
                        "get_line_color": [143, 188, 139],
                        "opacity": 0.15,
                        "stroked": True,
                        "get_line_width": 1.55,
                    },
                    "National Park": {
                        "get_fill_color": [255, 250, 205],
                        "get_line_color": [255, 250, 205],
                        "opacity": 0.15,
                        "stroked": True,
                        "get_line_width": 1.55,
                    },
                },
                "legends": {
                    "Community Conservancy": {
                        "labels": ["Community Conservancy"],
                        "colors": ["#556b2f"],
                    },
                    "National Reserve": {
                        "labels": ["National Reserve"],
                        "colors": ["#8fbc8b"],
                    },
                    "National Park": {
                        "labels": ["National Park"],
                        "colors": ["#fffacd"],
                    },
                },
            }
            | (params_dict.get("create_styled_landdx_layers") or {}),
            method="call",
        ),
        "er_client_name": Node(
            async_task=set_er_connection.validate()
            .set_task_instance_id("er_client_name")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("er_client_name") or {}),
            method="call",
        ),
        "gee_project_name": Node(
            async_task=set_gee_connection.validate()
            .set_task_instance_id("gee_project_name")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("gee_project_name") or {}),
            method="call",
        ),
        "subject_observations": Node(
            async_task=get_subjectgroup_observations.validate()
            .set_task_instance_id("subject_observations")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("time_range"),
                "raise_on_empty": False,
                "include_details": False,
                "include_subjectsource_details": False,
            }
            | (params_dict.get("subject_observations") or {}),
            method="call",
        ),
        "subject_reloc": Node(
            async_task=process_relocations.validate()
            .set_task_instance_id("subject_reloc")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "observations": DependsOn("subject_observations"),
                "relocs_columns": [
                    "groupby_col",
                    "fixtime",
                    "junk_status",
                    "geometry",
                    "extra__subject__name",
                    "extra__subject__hex",
                    "extra__subject__sex",
                    "extra__created_at",
                    "extra__subject__subject_subtype",
                ],
                "filter_point_coords": [
                    {"x": 180.0, "y": 90.0},
                    {"x": 0.0, "y": 0.0},
                    {"x": 1.0, "y": 1.0},
                ],
            }
            | (params_dict.get("subject_reloc") or {}),
            method="call",
        ),
        "annotate_day_night": Node(
            async_task=classify_is_night.validate()
            .set_task_instance_id("annotate_day_night")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("subject_reloc"),
            }
            | (params_dict.get("annotate_day_night") or {}),
            method="call",
        ),
        "convert_to_trajectories": Node(
            async_task=relocations_to_trajectory.validate()
            .set_task_instance_id("convert_to_trajectories")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("annotate_day_night"),
            }
            | (params_dict.get("convert_to_trajectories") or {}),
            method="call",
        ),
        "add_temporal_index_to_traj": Node(
            async_task=add_temporal_index.validate()
            .set_task_instance_id("add_temporal_index_to_traj")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("convert_to_trajectories"),
                "time_col": "segment_start",
                "groupers": DependsOn("groupers"),
                "cast_to_datetime": True,
                "format": "mixed",
            }
            | (params_dict.get("add_temporal_index_to_traj") or {}),
            method="call",
        ),
        "classify_trajectory_speed_bins": Node(
            async_task=apply_classification.validate()
            .set_task_instance_id("classify_trajectory_speed_bins")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("add_temporal_index_to_traj"),
                "input_column_name": "speed_kmhr",
                "output_column_name": "speed_bins",
                "classification_options": {"scheme": "equal_interval", "k": 6},
                "label_options": {"label_ranges": False, "label_decimals": 1},
            }
            | (params_dict.get("classify_trajectory_speed_bins") or {}),
            method="call",
        ),
        "label_trajectory_quarters": Node(
            async_task=label_quarter_status.validate()
            .set_task_instance_id("label_trajectory_quarters")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("classify_trajectory_speed_bins"),
                "timestamp_col": "segment_start",
            }
            | (params_dict.get("label_trajectory_quarters") or {}),
            method="call",
        ),
        "rename_traj_cols": Node(
            async_task=map_columns.validate()
            .set_task_instance_id("rename_traj_cols")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "drop_columns": [],
                "retain_columns": [],
                "rename_columns": {
                    "extra__hex": "hex_color",
                    "extra__is_night": "is_night",
                    "extra__name": "subject_name",
                    "extra__sex": "subject_sex",
                    "extra__subject_subtype": "subject_subtype",
                    "extra__created_at": "created_at",
                },
                "df": DependsOn("label_trajectory_quarters"),
            }
            | (params_dict.get("rename_traj_cols") or {}),
            method="call",
        ),
        "persist_trajectory_df": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_trajectory_df")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("rename_traj_cols"),
                "filetype": "gpkg",
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "trajectories",
            }
            | (params_dict.get("persist_trajectory_df") or {}),
            method="call",
        ),
        "persist_trajectory_gpq": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_trajectory_gpq")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("rename_traj_cols"),
                "filetype": "geoparquet",
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "trajectories",
            }
            | (params_dict.get("persist_trajectory_gpq") or {}),
            method="call",
        ),
        "persist_relocs_df": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_relocs_df")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("annotate_day_night"),
                "filetype": "gpkg",
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "relocations",
            }
            | (params_dict.get("persist_relocs_df") or {}),
            method="call",
        ),
        "persist_relocs_gpq": Node(
            async_task=persist_df.validate()
            .set_task_instance_id("persist_relocs_gpq")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("annotate_day_night"),
                "filetype": "geoparquet",
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": "relocations",
            }
            | (params_dict.get("persist_relocs_gpq") or {}),
            method="call",
        ),
        "split_trajectories_by_group": Node(
            async_task=split_groups.validate()
            .set_task_instance_id("split_trajectories_by_group")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("rename_traj_cols"),
                "groupers": DependsOn("groupers"),
            }
            | (params_dict.get("split_trajectories_by_group") or {}),
            method="call",
        ),
        "split_group_column": Node(
            async_task=get_split_group_column.validate()
            .set_task_instance_id("split_group_column")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "split_data": DependsOn("split_trajectories_by_group"),
            }
            | (params_dict.get("split_group_column") or {}),
            method="call",
        ),
        "assign_quarter_colors_traj": Node(
            async_task=modify_quarter_status_colors.validate()
            .set_task_instance_id("assign_quarter_colors_traj")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "grouper_value": DependsOn("split_group_column"),
            }
            | (params_dict.get("assign_quarter_colors_traj") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "sort_trajectories_by_speed": Node(
            async_task=sort_values.validate()
            .set_task_instance_id("sort_trajectories_by_speed")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "speed_bins",
                "na_position": "last",
                "ascending": True,
            }
            | (params_dict.get("sort_trajectories_by_speed") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("assign_quarter_colors_traj"),
            },
        ),
        "apply_speed_colormap": Node(
            async_task=apply_color_map.validate()
            .set_task_instance_id("apply_speed_colormap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "speed_bins",
                "output_column_name": "speed_bins_colormap",
                "colormap": [
                    "#1a9850",
                    "#91cf60",
                    "#d9ef8b",
                    "#fee08b",
                    "#fc8d59",
                    "#d73027",
                ],
            }
            | (params_dict.get("apply_speed_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_trajectories_by_speed"),
            },
        ),
        "format_speed_bin_labels": Node(
            async_task=map_values_with_unit.validate()
            .set_task_instance_id("format_speed_bin_labels")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "speed_bins",
                "output_column_name": "speed_bins_formatted",
                "original_unit": "km/h",
                "new_unit": "km/h",
                "decimal_places": 1,
            }
            | (params_dict.get("format_speed_bin_labels") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("apply_speed_colormap"),
            },
        ),
        "format_speed_values": Node(
            async_task=map_values_with_unit.validate()
            .set_task_instance_id("format_speed_values")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "speed_kmhr",
                "output_column_name": "speed_kmhr",
                "original_unit": "km/h",
                "new_unit": "km/h",
                "decimal_places": 1,
            }
            | (params_dict.get("format_speed_values") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("format_speed_bin_labels"),
            },
        ),
        "generate_speedmap_layers": Node(
            async_task=create_polyline_layer.validate()
            .set_task_instance_id("generate_speedmap_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {"color_column": "speed_bins_colormap"},
                "legend": {
                    "label_column": "speed_bins_formatted",
                    "color_column": "speed_bins_colormap",
                },
                "tooltip_columns": [
                    "is_night",
                    "subject_name",
                    "segment_start",
                    "dist_meters",
                    "timespan_seconds",
                    "subject_sex",
                ],
            }
            | (params_dict.get("generate_speedmap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("format_speed_values"),
            },
        ),
        "zoom_global_view": Node(
            async_task=create_view_state_from_gdf.validate()
            .set_task_instance_id("zoom_global_view")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "pitch": 0,
                "bearing": 0,
            }
            | (params_dict.get("zoom_global_view") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("format_speed_values"),
            },
        ),
        "ldx_speed_layers": Node(
            async_task=combine_map_layers.validate()
            .set_task_instance_id("ldx_speed_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOnSequence(
                    [
                        DependsOn("create_styled_landdx_layers"),
                        DependsOn("custom_text_layer"),
                    ],
                ),
            }
            | (params_dict.get("ldx_speed_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_speedmap_layers"),
            },
        ),
        "zip_speed_zoom_values": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("zip_speed_zoom_values")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("ldx_speed_layers"),
                        DependsOn("zoom_global_view"),
                    ],
                ),
            }
            | (params_dict.get("zip_speed_zoom_values") or {}),
            method="call",
        ),
        "draw_speed_ecomap": Node(
            async_task=draw_ecomap.validate()
            .set_task_instance_id("draw_speed_ecomap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Speed Values(Km/h)",
                },
                "static": False,
                "title": None,
                "max_zoom": 9,
            }
            | (params_dict.get("draw_speed_ecomap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers", "view_state"],
                "argvalues": DependsOn("zip_speed_zoom_values"),
            },
        ),
        "persist_speed_ecomap_urls": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_speed_ecomap_urls")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename_suffix": "speedmap",
            }
            | (params_dict.get("persist_speed_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_speed_ecomap"),
            },
        ),
        "create_speedmap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .set_task_instance_id("create_speedmap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Speed Map",
            }
            | (params_dict.get("create_speedmap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_speed_ecomap_urls"),
            },
        ),
        "merge_speedmap_widgets": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("merge_speedmap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_speedmap_widgets"),
            }
            | (params_dict.get("merge_speedmap_widgets") or {}),
            method="call",
        ),
        "sort_trajs_by_day_night": Node(
            async_task=sort_values.validate()
            .set_task_instance_id("sort_trajs_by_day_night")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "is_night",
                "ascending": False,
                "na_position": "last",
            }
            | (params_dict.get("sort_trajs_by_day_night") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("assign_quarter_colors_traj"),
            },
        ),
        "apply_day_night_colormap": Node(
            async_task=apply_color_map.validate()
            .set_task_instance_id("apply_day_night_colormap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "colormap": ["#292965", "#e7a553"],
                "input_column_name": "is_night",
                "output_column_name": "day_night_colors",
            }
            | (params_dict.get("apply_day_night_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_trajs_by_day_night"),
            },
        ),
        "generate_day_night_ecomap_layers": Node(
            async_task=create_polyline_layer.validate()
            .set_task_instance_id("generate_day_night_ecomap_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {"color_column": "day_night_colors"},
                "legend": {
                    "labels": ["Night", "Day"],
                    "colors": ["#292965", "#e7a553"],
                },
                "tooltip_columns": ["is_night", "subject_name", "subject_sex"],
            }
            | (params_dict.get("generate_day_night_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_day_night_colormap"),
            },
        ),
        "ldx_dn_layers": Node(
            async_task=combine_map_layers.validate()
            .set_task_instance_id("ldx_dn_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOnSequence(
                    [
                        DependsOn("create_styled_landdx_layers"),
                        DependsOn("custom_text_layer"),
                    ],
                ),
            }
            | (params_dict.get("ldx_dn_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_day_night_ecomap_layers"),
            },
        ),
        "zoom_day_night": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("zoom_day_night")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("ldx_dn_layers"),
                        DependsOn("zoom_global_view"),
                    ],
                ),
            }
            | (params_dict.get("zoom_day_night") or {}),
            method="call",
        ),
        "draw_day_night_ecomap": Node(
            async_task=draw_ecomap.validate()
            .set_task_instance_id("draw_day_night_ecomap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Night Day Tracks",
                },
                "static": False,
                "title": None,
                "max_zoom": 9,
            }
            | (params_dict.get("draw_day_night_ecomap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers", "view_state"],
                "argvalues": DependsOn("zoom_day_night"),
            },
        ),
        "persist_day_night_ecomap_urls": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_day_night_ecomap_urls")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename_suffix": "day_night",
            }
            | (params_dict.get("persist_day_night_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_day_night_ecomap"),
            },
        ),
        "create_day_night_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .set_task_instance_id("create_day_night_ecomap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Night Day Tracks",
            }
            | (params_dict.get("create_day_night_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_day_night_ecomap_urls"),
            },
        ),
        "merge_day_night_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("merge_day_night_ecomap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_day_night_ecomap_widgets"),
            }
            | (params_dict.get("merge_day_night_ecomap_widgets") or {}),
            method="call",
        ),
        "sort_trajs_by_quarter_status": Node(
            async_task=sort_values.validate()
            .set_task_instance_id("sort_trajs_by_quarter_status")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "quarter_status",
                "ascending": False,
                "na_position": "last",
            }
            | (params_dict.get("sort_trajs_by_quarter_status") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("assign_quarter_colors_traj"),
            },
        ),
        "generate_quarter_ecomap_layers": Node(
            async_task=create_polyline_layer.validate()
            .set_task_instance_id("generate_quarter_ecomap_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {"color_column": "quarter_status_colors"},
                "legend": {
                    "label_column": "quarter_status",
                    "color_column": "quarter_status_colors",
                },
                "tooltip_columns": [
                    "is_night",
                    "subject_name",
                    "subject_sex",
                    "quarter_status",
                ],
            }
            | (params_dict.get("generate_quarter_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("sort_trajs_by_quarter_status"),
            },
        ),
        "combine_quarter_ecomap_layers": Node(
            async_task=combine_map_layers.validate()
            .set_task_instance_id("combine_quarter_ecomap_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOnSequence(
                    [
                        DependsOn("create_styled_landdx_layers"),
                        DependsOn("custom_text_layer"),
                    ],
                ),
            }
            | (params_dict.get("combine_quarter_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_quarter_ecomap_layers"),
            },
        ),
        "zoom_quarter_movements": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("zoom_quarter_movements")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("combine_quarter_ecomap_layers"),
                        DependsOn("zoom_global_view"),
                    ],
                ),
            }
            | (params_dict.get("zoom_quarter_movements") or {}),
            method="call",
        ),
        "draw_quarter_status_ecomap": Node(
            async_task=draw_ecomap.validate()
            .set_task_instance_id("draw_quarter_status_ecomap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right", "title": "Legend"},
                "static": False,
                "title": None,
                "max_zoom": 9,
            }
            | (params_dict.get("draw_quarter_status_ecomap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers", "view_state"],
                "argvalues": DependsOn("zoom_quarter_movements"),
            },
        ),
        "persist_quarter_ecomap_urls": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_quarter_ecomap_urls")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename_suffix": "movement_tracks",
            }
            | (params_dict.get("persist_quarter_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_quarter_status_ecomap"),
            },
        ),
        "create_quarter_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .set_task_instance_id("create_quarter_ecomap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Movement Overview",
            }
            | (params_dict.get("create_quarter_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_quarter_ecomap_urls"),
            },
        ),
        "merge_quarter_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("merge_quarter_ecomap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_quarter_ecomap_widgets"),
            }
            | (params_dict.get("merge_quarter_ecomap_widgets") or {}),
            method="call",
        ),
        "generate_etd": Node(
            async_task=calculate_elliptical_time_density.validate()
            .set_task_instance_id("generate_etd")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "auto_scale_or_custom_cell_size": {
                    "auto_scale_or_custom": "Customize",
                    "grid_cell_size": 2000,
                },
                "crs": "ESRI:53042",
                "percentiles": [50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.9],
                "nodata_value": "nan",
                "band_count": 1,
                "max_speed_factor": 1.05,
                "expansion_factor": 1.3,
            }
            | (params_dict.get("generate_etd") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["trajectory_gdf"],
                "argvalues": DependsOn("assign_quarter_colors_traj"),
            },
        ),
        "determine_seasonal_windows": Node(
            async_task=determine_season_windows.validate()
            .set_task_instance_id("determine_seasonal_windows")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "client": DependsOn("gee_project_name"),
                "time_range": DependsOn("time_range"),
            }
            | (params_dict.get("determine_seasonal_windows") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["roi"],
                "argvalues": DependsOn("generate_etd"),
            },
        ),
        "zip_etd_and_grouped_trajs": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("zip_etd_and_grouped_trajs")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("determine_seasonal_windows"),
                        DependsOn("assign_quarter_colors_traj"),
                    ],
                ),
            }
            | (params_dict.get("zip_etd_and_grouped_trajs") or {}),
            method="call",
        ),
        "add_season_labels": Node(
            async_task=create_seasonal_labels.validate()
            .set_task_instance_id("add_season_labels")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("add_season_labels") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["seasons_df", "trajectories"],
                "argvalues": DependsOn("zip_etd_and_grouped_trajs"),
            },
        ),
        "calculate_mcp": Node(
            async_task=generate_mcp_gdf.validate()
            .set_task_instance_id("calculate_mcp")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "planar_crs": "ESRI:53042",
            }
            | (params_dict.get("calculate_mcp") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("assign_quarter_colors_traj"),
            },
        ),
        "apply_etd_percentile_colormap": Node(
            async_task=apply_color_map.validate()
            .set_task_instance_id("apply_etd_percentile_colormap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "percentile",
                "colormap": "RdYlGn",
                "output_column_name": "percentile_colormap",
            }
            | (params_dict.get("apply_etd_percentile_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("generate_etd"),
            },
        ),
        "generate_etd_ecomap_layers": Node(
            async_task=create_polygon_layer.validate()
            .set_task_instance_id("generate_etd_ecomap_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "percentile_colormap",
                    "opacity": 0.55,
                },
                "legend": {
                    "label_column": "percentile",
                    "color_column": "percentile_colormap",
                },
                "tooltip_columns": ["percentile"],
            }
            | (params_dict.get("generate_etd_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_etd_percentile_colormap"),
            },
        ),
        "generate_mcp_layers": Node(
            async_task=create_polygon_layer.validate()
            .set_task_instance_id("generate_mcp_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "get_fill_color": "#FFFFFF00",
                    "get_line_color": "#ff1493",
                    "get_line_width": 3.55,
                    "opacity": 0.75,
                    "stroked": True,
                },
                "legend": {"labels": ["MCP"], "colors": ["#ff1493"]},
                "tooltip_columns": ["area_km2"],
            }
            | (params_dict.get("generate_mcp_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("calculate_mcp"),
            },
        ),
        "zip_mcp_hr": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("zip_mcp_hr")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("generate_mcp_layers"),
                        DependsOn("generate_etd_ecomap_layers"),
                    ],
                ),
            }
            | (params_dict.get("zip_mcp_hr") or {}),
            method="call",
        ),
        "combine_landdx_hr_ecomap_layers": Node(
            async_task=combine_map_layers.validate()
            .set_task_instance_id("combine_landdx_hr_ecomap_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOnSequence(
                    [
                        DependsOn("create_styled_landdx_layers"),
                        DependsOn("custom_text_layer"),
                    ],
                ),
            }
            | (params_dict.get("combine_landdx_hr_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("zip_mcp_hr"),
            },
        ),
        "hr_view_zip": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("hr_view_zip")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("combine_landdx_hr_ecomap_layers"),
                        DependsOn("zoom_global_view"),
                    ],
                ),
            }
            | (params_dict.get("hr_view_zip") or {}),
            method="call",
        ),
        "draw_hr_ecomap": Node(
            async_task=draw_ecomap.validate()
            .set_task_instance_id("draw_hr_ecomap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right", "title": "ETD Metrics"},
                "static": False,
                "title": None,
                "max_zoom": 9,
            }
            | (params_dict.get("draw_hr_ecomap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers", "view_state"],
                "argvalues": DependsOn("hr_view_zip"),
            },
        ),
        "persist_hr_ecomap_urls": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("persist_hr_ecomap_urls")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename_suffix": "home_range",
            }
            | (params_dict.get("persist_hr_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_hr_ecomap"),
            },
        ),
        "create_hr_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .set_task_instance_id("create_hr_ecomap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Home Range",
            }
            | (params_dict.get("create_hr_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_hr_ecomap_urls"),
            },
        ),
        "merge_hr_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("merge_hr_ecomap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_hr_ecomap_widgets"),
            }
            | (params_dict.get("merge_hr_ecomap_widgets") or {}),
            method="call",
        ),
        "generate_speed_raster": Node(
            async_task=generate_ecograph_raster.validate()
            .set_task_instance_id("generate_speed_raster")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "step_length": 2000,
                "dist_col": "dist_meters",
                "interpolation": "mean",
                "movement_covariate": "speed",
                "radius": 2,
                "cutoff": None,
                "tortuosity_length": 3,
                "resolution": None,
                "network_metric": None,
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename": None,
            }
            | (params_dict.get("generate_speed_raster") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("assign_quarter_colors_traj"),
            },
        ),
        "extract_speed_rasters": Node(
            async_task=retrieve_feature_gdf.validate()
            .set_task_instance_id("extract_speed_rasters")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("extract_speed_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["file_path"],
                "argvalues": DependsOn("generate_speed_raster"),
            },
        ),
        "sort_speed_features_by_value": Node(
            async_task=sort_values.validate()
            .set_task_instance_id("sort_speed_features_by_value")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "value",
                "na_position": "last",
                "ascending": True,
            }
            | (params_dict.get("sort_speed_features_by_value") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("extract_speed_rasters"),
            },
        ),
        "classify_speed_features": Node(
            async_task=apply_classification.validate()
            .set_task_instance_id("classify_speed_features")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "value",
                "output_column_name": "bins",
                "classification_options": {"scheme": "natural_breaks", "k": 6},
                "label_options": {"label_ranges": False, "label_decimals": 1},
            }
            | (params_dict.get("classify_speed_features") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_speed_features_by_value"),
            },
        ),
        "apply_speed_raster_colormap": Node(
            async_task=apply_color_map.validate()
            .set_task_instance_id("apply_speed_raster_colormap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "speedraster_bins_colors",
                "colormap": [
                    "#1a9850",
                    "#91cf60",
                    "#d9ef8b",
                    "#fee08b",
                    "#fc8d59",
                    "#d73027",
                ],
            }
            | (params_dict.get("apply_speed_raster_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("classify_speed_features"),
            },
        ),
        "format_speed_raster_labels": Node(
            async_task=map_values_with_unit.validate()
            .set_task_instance_id("format_speed_raster_labels")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "bins_formatted",
                "original_unit": "km/h",
                "new_unit": "km/h",
                "decimal_places": 1,
            }
            | (params_dict.get("format_speed_raster_labels") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("apply_speed_raster_colormap"),
            },
        ),
        "generate_raster_layers": Node(
            async_task=create_polygon_layer.validate()
            .set_task_instance_id("generate_raster_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "speedraster_bins_colors",
                    "opacity": 0.55,
                },
                "legend": {
                    "label_column": "bins_formatted",
                    "color_column": "speedraster_bins_colors",
                },
                "tooltip_columns": ["value", "bins", "speedraster_bins_colors"],
            }
            | (params_dict.get("generate_raster_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("format_speed_raster_labels"),
            },
        ),
        "combine_seasonal_raster_layers": Node(
            async_task=combine_map_layers.validate()
            .set_task_instance_id("combine_seasonal_raster_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOnSequence(
                    [
                        DependsOn("create_styled_landdx_layers"),
                        DependsOn("custom_text_layer"),
                    ],
                ),
            }
            | (params_dict.get("combine_seasonal_raster_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_raster_layers"),
            },
        ),
        "speedraster_view_zip": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("speedraster_view_zip")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("combine_seasonal_raster_layers"),
                        DependsOn("zoom_global_view"),
                    ],
                ),
            }
            | (params_dict.get("speedraster_view_zip") or {}),
            method="call",
        ),
        "draw_speed_raster_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .set_task_instance_id("draw_speed_raster_ecomaps")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {
                    "placement": "bottom-right",
                    "title": "Mean Speed Value (km/h)",
                },
                "static": False,
                "title": None,
                "max_zoom": 9,
            }
            | (params_dict.get("draw_speed_raster_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers", "view_state"],
                "argvalues": DependsOn("speedraster_view_zip"),
            },
        ),
        "speed_raster_ecomap_urls": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("speed_raster_ecomap_urls")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename_suffix": "speed_raster",
            }
            | (params_dict.get("speed_raster_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_speed_raster_ecomaps"),
            },
        ),
        "speed_raster_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .set_task_instance_id("speed_raster_ecomap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Mean Speed Map",
            }
            | (params_dict.get("speed_raster_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("speed_raster_ecomap_urls"),
            },
        ),
        "speedraster_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("speedraster_ecomap_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("speed_raster_ecomap_widgets"),
            }
            | (params_dict.get("speedraster_ecomap_widgets") or {}),
            method="call",
        ),
        "seasonal_home_range": Node(
            async_task=calculate_seasonal_home_range.validate()
            .set_task_instance_id("seasonal_home_range")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                    all_geometry_are_none,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "groupby_cols": ["season"],
                "percentiles": [99.9],
                "auto_scale_or_custom_cell_size": {
                    "auto_scale_or_custom": "Customize",
                    "grid_cell_size": 2000,
                },
            }
            | (params_dict.get("seasonal_home_range") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("add_season_labels"),
            },
        ),
        "season_colormap": Node(
            async_task=apply_color_map.validate()
            .set_task_instance_id("season_colormap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "input_column_name": "season",
                "output_column_name": "season_colormap",
                "colormap": ["#f57c00", "#255084"],
            }
            | (params_dict.get("season_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("seasonal_home_range"),
            },
        ),
        "season_etd_map_layer": Node(
            async_task=create_polygon_layer.validate()
            .set_task_instance_id("season_etd_map_layer")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "season_colormap",
                    "opacity": 0.65,
                },
                "legend": {"label_column": "season", "color_column": "season_colormap"},
                "tooltip_columns": ["percentile"],
            }
            | (params_dict.get("season_etd_map_layer") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("season_colormap"),
            },
        ),
        "comb_season_map_layers": Node(
            async_task=combine_map_layers.validate()
            .set_task_instance_id("comb_season_map_layers")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOnSequence(
                    [
                        DependsOn("create_styled_landdx_layers"),
                        DependsOn("custom_text_layer"),
                    ],
                ),
            }
            | (params_dict.get("comb_season_map_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("season_etd_map_layer"),
            },
        ),
        "seasons_view_zip": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("seasons_view_zip")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("comb_season_map_layers"),
                        DependsOn("zoom_global_view"),
                    ],
                ),
            }
            | (params_dict.get("seasons_view_zip") or {}),
            method="call",
        ),
        "seasonal_ecomap": Node(
            async_task=draw_ecomap.validate()
            .set_task_instance_id("seasonal_ecomap")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right", "title": "Seasons"},
                "static": False,
                "title": None,
                "max_zoom": 9,
            }
            | (params_dict.get("seasonal_ecomap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers", "view_state"],
                "argvalues": DependsOn("seasons_view_zip"),
            },
        ),
        "season_etd_ecomap_html_url": Node(
            async_task=persist_text.validate()
            .set_task_instance_id("season_etd_ecomap_html_url")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "filename_suffix": "seasons",
            }
            | (params_dict.get("season_etd_ecomap_html_url") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("seasonal_ecomap"),
            },
        ),
        "season_etd_widgets_single_view": Node(
            async_task=create_map_widget_single_view.validate()
            .set_task_instance_id("season_etd_widgets_single_view")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Seasonal Home Range",
            }
            | (params_dict.get("season_etd_widgets_single_view") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("season_etd_ecomap_html_url"),
            },
        ),
        "season_grouped_map_widget": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("season_grouped_map_widget")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("season_etd_widgets_single_view"),
            }
            | (params_dict.get("season_grouped_map_widget") or {}),
            method="call",
        ),
        "total_mcp_area": Node(
            async_task=dataframe_column_sum.validate()
            .set_task_instance_id("total_mcp_area")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "area_km2",
            }
            | (params_dict.get("total_mcp_area") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("calculate_mcp"),
            },
        ),
        "round_mcp_area": Node(
            async_task=round_off_values.validate()
            .set_task_instance_id("round_mcp_area")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "dp": 2,
            }
            | (params_dict.get("round_mcp_area") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["value"],
                "argvalues": DependsOn("total_mcp_area"),
            },
        ),
        "total_grid_area": Node(
            async_task=dataframe_column_sum.validate()
            .set_task_instance_id("total_grid_area")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "area_sqkm",
            }
            | (params_dict.get("total_grid_area") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("generate_etd"),
            },
        ),
        "round_grid_area": Node(
            async_task=round_off_values.validate()
            .set_task_instance_id("round_grid_area")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "dp": 1,
            }
            | (params_dict.get("round_grid_area") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["value"],
                "argvalues": DependsOn("total_grid_area"),
            },
        ),
        "total_mcp_sv_widgets": Node(
            async_task=create_single_value_widget_single_view.validate()
            .set_task_instance_id("total_mcp_sv_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Total MCP Area (Km2)",
                "decimal_places": 1,
            }
            | (params_dict.get("total_mcp_sv_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("round_mcp_area"),
            },
        ),
        "total_mcp_grouped_sv_widget": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("total_mcp_grouped_sv_widget")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("total_mcp_sv_widgets"),
            }
            | (params_dict.get("total_mcp_grouped_sv_widget") or {}),
            method="call",
        ),
        "total_grid_sv_widgets": Node(
            async_task=create_single_value_widget_single_view.validate()
            .set_task_instance_id("total_grid_sv_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Total Grid Area(Km2)",
                "decimal_places": 1,
            }
            | (params_dict.get("total_grid_sv_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("round_grid_area"),
            },
        ),
        "total_grid_grouped_sv_widget": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("total_grid_grouped_sv_widget")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("total_grid_sv_widgets"),
            }
            | (params_dict.get("total_grid_grouped_sv_widget") or {}),
            method="call",
        ),
        "subject_gender": Node(
            async_task=dataframe_column_first_unique_str.validate()
            .set_task_instance_id("subject_gender")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "subject_sex",
            }
            | (params_dict.get("subject_gender") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("assign_quarter_colors_traj"),
            },
        ),
        "gender_widgets": Node(
            async_task=create_text_widget_single_view.validate()
            .set_task_instance_id("gender_widgets")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Gender",
            }
            | (params_dict.get("gender_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("subject_gender"),
            },
        ),
        "gender_sv_widget": Node(
            async_task=merge_widget_views.validate()
            .set_task_instance_id("gender_sv_widget")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("gender_widgets"),
            }
            | (params_dict.get("gender_sv_widget") or {}),
            method="call",
        ),
        "report_duration": Node(
            async_task=get_duration.validate()
            .set_task_instance_id("report_duration")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "time_range": DependsOn("time_range"),
                "time_unit": "months",
            }
            | (params_dict.get("report_duration") or {}),
            method="call",
        ),
        "round_report_duration": Node(
            async_task=round_off_values.validate()
            .set_task_instance_id("round_report_duration")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "dp": 2,
                "value": DependsOn("report_duration"),
            }
            | (params_dict.get("round_report_duration") or {}),
            method="call",
        ),
        "get_subject_name": Node(
            async_task=dataframe_column_first_unique_str.validate()
            .set_task_instance_id("get_subject_name")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "column_name": "subject_name",
            }
            | (params_dict.get("get_subject_name") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("assign_quarter_colors_traj"),
            },
        ),
        "unique_subjects": Node(
            async_task=dataframe_column_nunique.validate()
            .set_task_instance_id("unique_subjects")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "df": DependsOn("rename_traj_cols"),
                "column_name": "subject_name",
            }
            | (params_dict.get("unique_subjects") or {}),
            method="call",
        ),
        "create_cover_template_context": Node(
            async_task=build_mapbook_report_template.validate()
            .set_task_instance_id("create_cover_template_context")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "count": DependsOn("unique_subjects"),
                "org_logo_path": DependsOn("download_logo_path"),
                "report_period": DependsOn("time_range"),
                "prepared_by": "Ecoscope",
            }
            | (params_dict.get("create_cover_template_context") or {}),
            method="call",
        ),
        "persist_context_cover": Node(
            async_task=create_context_page.validate()
            .set_task_instance_id("persist_context_cover")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "logo_width_cm": 4.5,
                "logo_height_cm": 1.93,
                "template_path": DependsOn("download_mapbook_cover_page"),
                "output_directory": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "context": DependsOn("create_cover_template_context"),
                "filename": None,
            }
            | (params_dict.get("persist_context_cover") or {}),
            method="call",
        ),
        "convert_speedmap_html_to_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_speedmap_html_to_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "config": {"wait_for_timeout": 40000},
            }
            | (params_dict.get("convert_speedmap_html_to_png") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["html_path"],
                "argvalues": DependsOn("persist_speed_ecomap_urls"),
            },
        ),
        "convert_day_night_html_to_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_day_night_html_to_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "config": {"wait_for_timeout": 40000},
            }
            | (params_dict.get("convert_day_night_html_to_png") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["html_path"],
                "argvalues": DependsOn("persist_day_night_ecomap_urls"),
            },
        ),
        "convert_quarter_html_to_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_quarter_html_to_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "config": {"wait_for_timeout": 40000},
            }
            | (params_dict.get("convert_quarter_html_to_png") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["html_path"],
                "argvalues": DependsOn("persist_quarter_ecomap_urls"),
            },
        ),
        "convert_hr_html_to_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_hr_html_to_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "config": {"wait_for_timeout": 40000},
            }
            | (params_dict.get("convert_hr_html_to_png") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["html_path"],
                "argvalues": DependsOn("persist_hr_ecomap_urls"),
            },
        ),
        "convert_speed_raster_html_to_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_speed_raster_html_to_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "config": {"wait_for_timeout": 40000},
            }
            | (params_dict.get("convert_speed_raster_html_to_png") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["html_path"],
                "argvalues": DependsOn("speed_raster_ecomap_urls"),
            },
        ),
        "convert_seasonal_hr_html_to_png": Node(
            async_task=html_to_png.validate()
            .set_task_instance_id("convert_seasonal_hr_html_to_png")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "output_dir": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "config": {"wait_for_timeout": 40000},
            }
            | (params_dict.get("convert_seasonal_hr_html_to_png") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["html_path"],
                "argvalues": DependsOn("season_etd_ecomap_html_url"),
            },
        ),
        "zip_mapbook_context": Node(
            async_task=groupbykey.validate()
            .set_task_instance_id("zip_mapbook_context")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "iterables": DependsOnSequence(
                    [
                        DependsOn("round_grid_area"),
                        DependsOn("round_mcp_area"),
                        DependsOn("convert_quarter_html_to_png"),
                        DependsOn("convert_hr_html_to_png"),
                        DependsOn("convert_speed_raster_html_to_png"),
                        DependsOn("convert_day_night_html_to_png"),
                        DependsOn("convert_speedmap_html_to_png"),
                        DependsOn("convert_seasonal_hr_html_to_png"),
                        DependsOn("get_subject_name"),
                    ],
                ),
            }
            | (params_dict.get("zip_mapbook_context") or {}),
            method="call",
        ),
        "flatten_mbook_context": Node(
            async_task=flatten_tuple.validate()
            .set_task_instance_id("flatten_mbook_context")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("flatten_mbook_context") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["nested"],
                "argvalues": DependsOn("zip_mapbook_context"),
            },
        ),
        "get_grouper_names": Node(
            async_task=get_split_group_names.validate()
            .set_task_instance_id("get_grouper_names")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "split_data": DependsOn("split_trajectories_by_group"),
            }
            | (params_dict.get("get_grouper_names") or {}),
            method="call",
        ),
        "zip_grouper_with_context": Node(
            async_task=zip_lists.validate()
            .set_task_instance_id("zip_grouper_with_context")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "left": DependsOn("get_grouper_names"),
                "right": DependsOn("flatten_mbook_context"),
            }
            | (params_dict.get("zip_grouper_with_context") or {}),
            method="call",
        ),
        "flatten_final_report_context": Node(
            async_task=flatten_tuple.validate()
            .set_task_instance_id("flatten_final_report_context")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("flatten_final_report_context") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["nested"],
                "argvalues": DependsOn("zip_grouper_with_context"),
            },
        ),
        "prepare_mapbook_context": Node(
            async_task=create_report_context_from_tuple.validate()
            .set_task_instance_id("prepare_mapbook_context")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial=(params_dict.get("prepare_mapbook_context") or {}),
            method="mapvalues",
            kwargs={
                "argnames": [
                    "grouper_type",
                    "grouper_eq",
                    "grouper_value",
                    "grid_area",
                    "mcp_area",
                    "movement_tracks_ecomap",
                    "home_range_ecomap",
                    "speed_raster_ecomap",
                    "night_day_ecomap",
                    "speedmap",
                    "seasonal_homerange",
                    "subject_name",
                ],
                "argvalues": DependsOn("flatten_final_report_context"),
            },
        ),
        "individual_mapbook_context": Node(
            async_task=create_mapbook_context.validate()
            .set_task_instance_id("individual_mapbook_context")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "template_path": DependsOn("download_sect_templates"),
                "output_directory": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "time_period": DependsOn("time_range"),
                "period": DependsOn("round_report_duration"),
                "filename": None,
                "validate_images": True,
                "box_h_cm": 6.5,
                "box_w_cm": 11.11,
            }
            | (params_dict.get("individual_mapbook_context") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["context"],
                "argvalues": DependsOn("prepare_mapbook_context"),
            },
        ),
        "generate_mapbook_report": Node(
            async_task=merge_docx_files.validate()
            .set_task_instance_id("generate_mapbook_report")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "cover_page_path": DependsOn("persist_context_cover"),
                "output_directory": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
                "context_page_items": DependsOn("individual_mapbook_context"),
                "filename": "mapbook_report.docx",
            }
            | (params_dict.get("generate_mapbook_report") or {}),
            method="call",
        ),
        "mapbook_dashboard": Node(
            async_task=gather_dashboard.validate()
            .set_task_instance_id("mapbook_dashboard")
            .handle_errors()
            .with_tracing()
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "details": DependsOn("initialize_workflow_metadata"),
                "widgets": DependsOnSequence(
                    [
                        DependsOn("gender_sv_widget"),
                        DependsOn("total_mcp_grouped_sv_widget"),
                        DependsOn("total_grid_grouped_sv_widget"),
                        DependsOn("merge_quarter_ecomap_widgets"),
                        DependsOn("merge_hr_ecomap_widgets"),
                        DependsOn("merge_speedmap_widgets"),
                        DependsOn("speedraster_ecomap_widgets"),
                        DependsOn("merge_day_night_ecomap_widgets"),
                        DependsOn("season_grouped_map_widget"),
                    ],
                ),
                "time_range": DependsOn("time_range"),
                "groupers": DependsOn("groupers"),
            }
            | (params_dict.get("mapbook_dashboard") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
