# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details

# ruff: noqa: E402

"""WARNING: This file is generated in a testing context and should not be used in production.
Lines specific to the testing context are marked with a test tube emoji (ðŸ§ª) to indicate
that they would not be included (or would be different) in the production version of this file.
"""

import json
import os
import warnings  # ðŸ§ª
from ecoscope_workflows_core.testing import create_task_magicmock  # ðŸ§ª


from ecoscope_workflows_core.graph import DependsOn, DependsOnSequence, Graph, Node

from ecoscope_workflows_core.tasks.config import set_workflow_details
from ecoscope_workflows_core.tasks.filter import set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers
from ecoscope_workflows_ext_ecoscope.tasks.results import set_base_maps
from ecoscope_workflows_ext_ste.tasks import create_directory
from ecoscope_workflows_ext_ste.tasks import download_land_dx
from ecoscope_workflows_ext_ste.tasks import load_landdx_aoi
from ecoscope_workflows_ext_ste.tasks import split_gdf_by_column
from ecoscope_workflows_ext_ste.tasks import annotate_gdf_dict_with_geometry_type
from ecoscope_workflows_ext_ste.tasks import create_map_layers_from_annotated_dict
from ecoscope_workflows_core.tasks.io import set_er_connection
from ecoscope_workflows_core.tasks.io import set_gee_connection

get_subjectgroup_observations = create_task_magicmock(  # ðŸ§ª
    anchor="ecoscope_workflows_ext_ecoscope.tasks.io",  # ðŸ§ª
    func_name="get_subjectgroup_observations",  # ðŸ§ª
)  # ðŸ§ª
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import process_relocations
from ecoscope_workflows_ext_ecoscope.tasks.transformation import classify_is_night
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import (
    relocations_to_trajectory,
)
from ecoscope_workflows_core.tasks.transformation import add_temporal_index
from ecoscope_workflows_ext_ecoscope.tasks.transformation import apply_classification
from ecoscope_workflows_ext_ste.tasks import label_quarter_status
from ecoscope_workflows_ext_ecoscope.tasks.analysis import (
    calculate_elliptical_time_density,
)
from ecoscope_workflows_core.tasks.groupby import split_groups
from ecoscope_workflows_core.tasks.transformation import sort_values
from ecoscope_workflows_ext_ecoscope.tasks.transformation import apply_color_map
from ecoscope_workflows_core.tasks.transformation import map_values_with_unit
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polyline_layer
from ecoscope_workflows_core.tasks.skip import any_is_empty_df
from ecoscope_workflows_core.tasks.skip import any_dependency_skipped
from ecoscope_workflows_ext_ste.tasks import combine_map_layers
from ecoscope_workflows_ext_ecoscope.tasks.results import draw_ecomap
from ecoscope_workflows_core.tasks.io import persist_text
from ecoscope_workflows_core.tasks.results import create_map_widget_single_view
from ecoscope_workflows_core.tasks.skip import never
from ecoscope_workflows_core.tasks.results import merge_widget_views
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polygon_layer
from ecoscope_workflows_ext_ste.tasks import generate_speed_raster
from ecoscope_workflows_ext_ste.tasks import retrieve_feature_gdf
from ecoscope_workflows_core.tasks.results import gather_dashboard

from ..params import Params


def main(params: Params):
    warnings.warn("This test script should not be used in production!")  # ðŸ§ª

    params_dict = json.loads(params.model_dump_json(exclude_unset=True))

    dependencies = {
        "initialize_workflow_metadata": [],
        "define_time_range": [],
        "configure_grouping_strategy": [],
        "configure_base_maps": [],
        "create_output_directory": [],
        "retrieve_landdx_database": ["create_output_directory"],
        "load_aoi": ["retrieve_landdx_database"],
        "split_landdx_by_type": ["load_aoi"],
        "annotate_geometry_types": ["split_landdx_by_type"],
        "create_styled_landdx_layers": ["annotate_geometry_types"],
        "er_client_name": [],
        "gee_project_name": [],
        "subject_observations": ["er_client_name", "define_time_range"],
        "subject_reloc": ["subject_observations"],
        "annotate_day_night": ["subject_reloc"],
        "convert_to_trajectories": ["annotate_day_night"],
        "add_temporal_index_to_traj": [
            "convert_to_trajectories",
            "configure_grouping_strategy",
        ],
        "classify_trajectory_speed_bins": ["add_temporal_index_to_traj"],
        "label_trajectory_quarters": ["classify_trajectory_speed_bins"],
        "generate_seasonal_etd": ["label_trajectory_quarters"],
        "split_trajectories_by_group": [
            "label_trajectory_quarters",
            "configure_grouping_strategy",
        ],
        "sort_trajectories_by_speed": ["split_trajectories_by_group"],
        "apply_speed_colormap": ["sort_trajectories_by_speed"],
        "format_speed_bin_labels": ["apply_speed_colormap"],
        "format_speed_values": ["format_speed_bin_labels"],
        "generate_speed_ecomap_layers": ["format_speed_values"],
        "combine_landdx_speed_layers": [
            "create_styled_landdx_layers",
            "generate_speed_ecomap_layers",
        ],
        "draw_speed_ecomaps": ["configure_base_maps", "combine_landdx_speed_layers"],
        "persist_speed_ecomap_urls": ["draw_speed_ecomaps"],
        "create_speed_ecomap_widgets": ["persist_speed_ecomap_urls"],
        "merge_speed_ecomap_widgets": ["create_speed_ecomap_widgets"],
        "sort_trajectories_by_day_night": ["split_trajectories_by_group"],
        "apply_day_night_colormap": ["sort_trajectories_by_day_night"],
        "generate_day_night_ecomap_layers": ["apply_day_night_colormap"],
        "combine_landdx_dn_ecomap_layers": [
            "create_styled_landdx_layers",
            "generate_day_night_ecomap_layers",
        ],
        "draw_day_night_ecomaps": [
            "configure_base_maps",
            "combine_landdx_dn_ecomap_layers",
        ],
        "persist_day_night_ecomap_urls": ["draw_day_night_ecomaps"],
        "create_day_night_ecomap_widgets": ["persist_day_night_ecomap_urls"],
        "merge_day_night_ecomap_widgets": ["create_day_night_ecomap_widgets"],
        "sort_trajs_by_quarter_status": ["split_trajectories_by_group"],
        "apply_quarter_status_colormap": ["sort_trajs_by_quarter_status"],
        "generate_quarter_ecomap_layers": ["apply_quarter_status_colormap"],
        "combine_quarter_ecomap_layers": [
            "create_styled_landdx_layers",
            "generate_quarter_ecomap_layers",
        ],
        "draw_quarter_status_ecomaps": [
            "configure_base_maps",
            "combine_quarter_ecomap_layers",
        ],
        "persist_quarter_ecomap_urls": ["draw_quarter_status_ecomaps"],
        "create_quarter_ecomap_widgets": ["persist_quarter_ecomap_urls"],
        "merge_quarter_ecomap_widgets": ["create_quarter_ecomap_widgets"],
        "generate_etd": ["split_trajectories_by_group"],
        "apply_etd_percentile_colormap": ["generate_etd"],
        "generate_etd_ecomap_layers": ["apply_etd_percentile_colormap"],
        "combine_landdx_hr_ecomap_layers": [
            "create_styled_landdx_layers",
            "generate_etd_ecomap_layers",
        ],
        "draw_hr_ecomaps": ["configure_base_maps", "combine_landdx_hr_ecomap_layers"],
        "persist_hr_ecomap_urls": ["draw_hr_ecomaps"],
        "create_hr_ecomap_widgets": ["persist_hr_ecomap_urls"],
        "merge_hr_ecomap_widgets": ["create_hr_ecomap_widgets"],
        "generate_speed_rasters": [
            "create_output_directory",
            "split_trajectories_by_group",
        ],
        "extract_speed_rasters": ["generate_speed_rasters"],
        "sort_speed_features_by_value": ["extract_speed_rasters"],
        "classify_speed_features": ["sort_speed_features_by_value"],
        "apply_speed_raster_colormap": ["classify_speed_features"],
        "format_speed_raster_labels": ["apply_speed_raster_colormap"],
        "generate_raster_layers": ["format_speed_raster_labels"],
        "combine_seasonal_raster_layers": [
            "create_styled_landdx_layers",
            "generate_raster_layers",
        ],
        "draw_speed_raster_ecomaps": [
            "configure_base_maps",
            "combine_seasonal_raster_layers",
        ],
        "speed_raster_ecomap_urls": ["draw_speed_raster_ecomaps"],
        "speed_raster_ecomap_widgets": ["speed_raster_ecomap_urls"],
        "speedraster_ecomap_widgets": ["speed_raster_ecomap_widgets"],
        "mapbook_dashboard": [
            "initialize_workflow_metadata",
            "merge_speed_ecomap_widgets",
            "merge_day_night_ecomap_widgets",
            "merge_quarter_ecomap_widgets",
            "merge_hr_ecomap_widgets",
            "speedraster_ecomap_widgets",
            "define_time_range",
            "configure_grouping_strategy",
        ],
    }

    nodes = {
        "initialize_workflow_metadata": Node(
            async_task=set_workflow_details.validate()
            .handle_errors(task_instance_id="initialize_workflow_metadata")
            .set_executor("lithops"),
            partial=(params_dict.get("initialize_workflow_metadata") or {}),
            method="call",
        ),
        "define_time_range": Node(
            async_task=set_time_range.validate()
            .handle_errors(task_instance_id="define_time_range")
            .set_executor("lithops"),
            partial={
                "time_format": "%d %b %Y %H:%M:%S %Z",
            }
            | (params_dict.get("define_time_range") or {}),
            method="call",
        ),
        "configure_grouping_strategy": Node(
            async_task=set_groupers.validate()
            .handle_errors(task_instance_id="configure_grouping_strategy")
            .set_executor("lithops"),
            partial=(params_dict.get("configure_grouping_strategy") or {}),
            method="call",
        ),
        "configure_base_maps": Node(
            async_task=set_base_maps.validate()
            .handle_errors(task_instance_id="configure_base_maps")
            .set_executor("lithops"),
            partial=(params_dict.get("configure_base_maps") or {}),
            method="call",
        ),
        "create_output_directory": Node(
            async_task=create_directory.validate()
            .handle_errors(task_instance_id="create_output_directory")
            .set_executor("lithops"),
            partial=(params_dict.get("create_output_directory") or {}),
            method="call",
        ),
        "retrieve_landdx_database": Node(
            async_task=download_land_dx.validate()
            .handle_errors(task_instance_id="retrieve_landdx_database")
            .set_executor("lithops"),
            partial={
                "path": DependsOn("create_output_directory"),
            }
            | (params_dict.get("retrieve_landdx_database") or {}),
            method="call",
        ),
        "load_aoi": Node(
            async_task=load_landdx_aoi.validate()
            .handle_errors(task_instance_id="load_aoi")
            .set_executor("lithops"),
            partial={
                "map_path": DependsOn("retrieve_landdx_database"),
            }
            | (params_dict.get("load_aoi") or {}),
            method="call",
        ),
        "split_landdx_by_type": Node(
            async_task=split_gdf_by_column.validate()
            .handle_errors(task_instance_id="split_landdx_by_type")
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("load_aoi"),
                "column": "type",
            }
            | (params_dict.get("split_landdx_by_type") or {}),
            method="call",
        ),
        "annotate_geometry_types": Node(
            async_task=annotate_gdf_dict_with_geometry_type.validate()
            .handle_errors(task_instance_id="annotate_geometry_types")
            .set_executor("lithops"),
            partial={
                "gdf_dict": DependsOn("split_landdx_by_type"),
            }
            | (params_dict.get("annotate_geometry_types") or {}),
            method="call",
        ),
        "create_styled_landdx_layers": Node(
            async_task=create_map_layers_from_annotated_dict.validate()
            .handle_errors(task_instance_id="create_styled_landdx_layers")
            .set_executor("lithops"),
            partial={
                "annotated_dict": DependsOn("annotate_geometry_types"),
            }
            | (params_dict.get("create_styled_landdx_layers") or {}),
            method="call",
        ),
        "er_client_name": Node(
            async_task=set_er_connection.validate()
            .handle_errors(task_instance_id="er_client_name")
            .set_executor("lithops"),
            partial=(params_dict.get("er_client_name") or {}),
            method="call",
        ),
        "gee_project_name": Node(
            async_task=set_gee_connection.validate()
            .handle_errors(task_instance_id="gee_project_name")
            .set_executor("lithops"),
            partial=(params_dict.get("gee_project_name") or {}),
            method="call",
        ),
        "subject_observations": Node(
            async_task=get_subjectgroup_observations.validate()
            .handle_errors(task_instance_id="subject_observations")
            .set_executor("lithops"),
            partial={
                "client": DependsOn("er_client_name"),
                "time_range": DependsOn("define_time_range"),
                "raise_on_empty": False,
                "include_details": False,
                "include_subjectsource_details": False,
            }
            | (params_dict.get("subject_observations") or {}),
            method="call",
        ),
        "subject_reloc": Node(
            async_task=process_relocations.validate()
            .handle_errors(task_instance_id="subject_reloc")
            .set_executor("lithops"),
            partial={
                "observations": DependsOn("subject_observations"),
                "relocs_columns": [
                    "groupby_col",
                    "fixtime",
                    "junk_status",
                    "geometry",
                    "extra__subject__name",
                    "extra__subject__subject_subtype",
                    "extra__subject__sex",
                    "extra__created_at",
                ],
                "filter_point_coords": [
                    {"x": 180.0, "y": 90.0},
                    {"x": 0.0, "y": 0.0},
                    {"x": 1.0, "y": 1.0},
                ],
            }
            | (params_dict.get("subject_reloc") or {}),
            method="call",
        ),
        "annotate_day_night": Node(
            async_task=classify_is_night.validate()
            .handle_errors(task_instance_id="annotate_day_night")
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("subject_reloc"),
            }
            | (params_dict.get("annotate_day_night") or {}),
            method="call",
        ),
        "convert_to_trajectories": Node(
            async_task=relocations_to_trajectory.validate()
            .handle_errors(task_instance_id="convert_to_trajectories")
            .set_executor("lithops"),
            partial={
                "relocations": DependsOn("annotate_day_night"),
            }
            | (params_dict.get("convert_to_trajectories") or {}),
            method="call",
        ),
        "add_temporal_index_to_traj": Node(
            async_task=add_temporal_index.validate()
            .handle_errors(task_instance_id="add_temporal_index_to_traj")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("convert_to_trajectories"),
                "time_col": "segment_start",
                "groupers": DependsOn("configure_grouping_strategy"),
                "cast_to_datetime": True,
                "format": "mixed",
            }
            | (params_dict.get("add_temporal_index_to_traj") or {}),
            method="call",
        ),
        "classify_trajectory_speed_bins": Node(
            async_task=apply_classification.validate()
            .handle_errors(task_instance_id="classify_trajectory_speed_bins")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("add_temporal_index_to_traj"),
                "input_column_name": "speed_kmhr",
                "output_column_name": "speed_bins",
                "classification_options": {"scheme": "equal_interval", "k": 6},
                "label_options": {"label_ranges": False, "label_decimals": 1},
            }
            | (params_dict.get("classify_trajectory_speed_bins") or {}),
            method="call",
        ),
        "label_trajectory_quarters": Node(
            async_task=label_quarter_status.validate()
            .handle_errors(task_instance_id="label_trajectory_quarters")
            .set_executor("lithops"),
            partial={
                "gdf": DependsOn("classify_trajectory_speed_bins"),
                "timestamp_col": "segment_start",
            }
            | (params_dict.get("label_trajectory_quarters") or {}),
            method="call",
        ),
        "generate_seasonal_etd": Node(
            async_task=calculate_elliptical_time_density.validate()
            .handle_errors(task_instance_id="generate_seasonal_etd")
            .set_executor("lithops"),
            partial={
                "crs": "ESRI:53042",
                "percentiles": [50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
                "nodata_value": "nan",
                "band_count": 1,
                "trajectory_gdf": DependsOn("label_trajectory_quarters"),
            }
            | (params_dict.get("generate_seasonal_etd") or {}),
            method="call",
        ),
        "split_trajectories_by_group": Node(
            async_task=split_groups.validate()
            .handle_errors(task_instance_id="split_trajectories_by_group")
            .set_executor("lithops"),
            partial={
                "df": DependsOn("label_trajectory_quarters"),
                "groupers": DependsOn("configure_grouping_strategy"),
            }
            | (params_dict.get("split_trajectories_by_group") or {}),
            method="call",
        ),
        "sort_trajectories_by_speed": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_trajectories_by_speed")
            .set_executor("lithops"),
            partial={
                "column_name": "speed_bins",
                "na_position": "last",
            }
            | (params_dict.get("sort_trajectories_by_speed") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "apply_speed_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_speed_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "speed_bins",
                "output_column_name": "speed_bins_colormap",
                "colormap": [
                    "#1a9850",
                    "#91cf60",
                    "#d9ef8b",
                    "#fee08b",
                    "#fc8d59",
                    "#d73027",
                ],
            }
            | (params_dict.get("apply_speed_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_trajectories_by_speed"),
            },
        ),
        "format_speed_bin_labels": Node(
            async_task=map_values_with_unit.validate()
            .handle_errors(task_instance_id="format_speed_bin_labels")
            .set_executor("lithops"),
            partial={
                "input_column_name": "speed_bins",
                "output_column_name": "speed_bins_formatted",
                "original_unit": "km/h",
                "new_unit": "km/h",
                "decimal_places": 1,
            }
            | (params_dict.get("format_speed_bin_labels") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("apply_speed_colormap"),
            },
        ),
        "format_speed_values": Node(
            async_task=map_values_with_unit.validate()
            .handle_errors(task_instance_id="format_speed_values")
            .set_executor("lithops"),
            partial={
                "input_column_name": "speed_kmhr",
                "output_column_name": "speed_kmhr",
                "original_unit": "km/h",
                "new_unit": "km/h",
                "decimal_places": 1,
            }
            | (params_dict.get("format_speed_values") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("format_speed_bin_labels"),
            },
        ),
        "generate_speed_ecomap_layers": Node(
            async_task=create_polyline_layer.validate()
            .handle_errors(task_instance_id="generate_speed_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {"color_column": "speed_bins_colormap"},
                "legend": {
                    "label_column": "speed_bins_formatted",
                    "color_column": "speed_bins_colormap",
                },
                "tooltip_columns": [
                    "extra__is_night",
                    "extra__name",
                    "segment_start",
                    "dist_meters",
                    "timespan_seconds",
                    "extra__sex",
                ],
            }
            | (params_dict.get("generate_speed_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("format_speed_values"),
            },
        ),
        "combine_landdx_speed_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_landdx_speed_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_landdx_speed_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_speed_ecomap_layers"),
            },
        ),
        "draw_speed_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_speed_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right"},
                "static": False,
                "title": None,
                "max_zoom": 10,
            }
            | (params_dict.get("draw_speed_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_landdx_speed_layers"),
            },
        ),
        "persist_speed_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_speed_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_speed_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_speed_ecomaps"),
            },
        ),
        "create_speed_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_speed_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Speed Ecomap",
            }
            | (params_dict.get("create_speed_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_speed_ecomap_urls"),
            },
        ),
        "merge_speed_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_speed_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_speed_ecomap_widgets"),
            }
            | (params_dict.get("merge_speed_ecomap_widgets") or {}),
            method="call",
        ),
        "sort_trajectories_by_day_night": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_trajectories_by_day_night")
            .set_executor("lithops"),
            partial={
                "column_name": "extra__is_night",
                "ascending": False,
                "na_position": "last",
            }
            | (params_dict.get("sort_trajectories_by_day_night") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "apply_day_night_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_day_night_colormap")
            .set_executor("lithops"),
            partial={
                "colormap": ["#292965", "#e7a553"],
                "input_column_name": "extra__is_night",
                "output_column_name": "day_night_colors",
            }
            | (params_dict.get("apply_day_night_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_trajectories_by_day_night"),
            },
        ),
        "generate_day_night_ecomap_layers": Node(
            async_task=create_polyline_layer.validate()
            .handle_errors(task_instance_id="generate_day_night_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {"color_column": "day_night_colors"},
                "legend": {
                    "labels": ["Night", "Day"],
                    "colors": ["#292965", "#e7a553"],
                },
                "tooltip_columns": ["extra__is_night", "extra__name", "extra__sex"],
            }
            | (params_dict.get("generate_day_night_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_day_night_colormap"),
            },
        ),
        "combine_landdx_dn_ecomap_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_landdx_dn_ecomap_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_landdx_dn_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_day_night_ecomap_layers"),
            },
        ),
        "draw_day_night_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_day_night_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right"},
                "static": False,
                "title": None,
                "max_zoom": 10,
            }
            | (params_dict.get("draw_day_night_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_landdx_dn_ecomap_layers"),
            },
        ),
        "persist_day_night_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_day_night_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_day_night_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_day_night_ecomaps"),
            },
        ),
        "create_day_night_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_day_night_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Day/Night Ecomap",
            }
            | (params_dict.get("create_day_night_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_day_night_ecomap_urls"),
            },
        ),
        "merge_day_night_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_day_night_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_day_night_ecomap_widgets"),
            }
            | (params_dict.get("merge_day_night_ecomap_widgets") or {}),
            method="call",
        ),
        "sort_trajs_by_quarter_status": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_trajs_by_quarter_status")
            .set_executor("lithops"),
            partial={
                "column_name": "quarter_status",
                "ascending": False,
                "na_position": "last",
            }
            | (params_dict.get("sort_trajs_by_quarter_status") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "apply_quarter_status_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_quarter_status_colormap")
            .set_executor("lithops"),
            partial={
                "colormap": ["#2f4f4f", "#ff8c00"],
                "input_column_name": "quarter_status",
                "output_column_name": "quarter_status_colors",
            }
            | (params_dict.get("apply_quarter_status_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_trajs_by_quarter_status"),
            },
        ),
        "generate_quarter_ecomap_layers": Node(
            async_task=create_polyline_layer.validate()
            .handle_errors(task_instance_id="generate_quarter_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {"color_column": "quarter_status_colors"},
                "legend": {
                    "labels": ["Previous Quarter", "Current Quarter"],
                    "colors": ["#2f4f4f", "#ff8c00"],
                },
                "tooltip_columns": [
                    "extra__is_night",
                    "extra__name",
                    "extra__sex",
                    "quarter_status",
                    "day_night_colors",
                ],
            }
            | (params_dict.get("generate_quarter_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_quarter_status_colormap"),
            },
        ),
        "combine_quarter_ecomap_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_quarter_ecomap_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_quarter_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_quarter_ecomap_layers"),
            },
        ),
        "draw_quarter_status_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_quarter_status_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right"},
                "static": False,
                "title": None,
                "max_zoom": 10,
            }
            | (params_dict.get("draw_quarter_status_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_quarter_ecomap_layers"),
            },
        ),
        "persist_quarter_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_quarter_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_quarter_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_quarter_status_ecomaps"),
            },
        ),
        "create_quarter_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_quarter_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Subject Group Quarter Movement Map",
            }
            | (params_dict.get("create_quarter_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_quarter_ecomap_urls"),
            },
        ),
        "merge_quarter_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_quarter_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_quarter_ecomap_widgets"),
            }
            | (params_dict.get("merge_quarter_ecomap_widgets") or {}),
            method="call",
        ),
        "generate_etd": Node(
            async_task=calculate_elliptical_time_density.validate()
            .handle_errors(task_instance_id="generate_etd")
            .set_executor("lithops"),
            partial={
                "crs": "ESRI:53042",
                "percentiles": [50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
                "nodata_value": "nan",
                "band_count": 1,
            }
            | (params_dict.get("generate_etd") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["trajectory_gdf"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "apply_etd_percentile_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_etd_percentile_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "percentile",
                "colormap": "RdYlGn",
                "output_column_name": "percentile_colormap",
            }
            | (params_dict.get("apply_etd_percentile_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("generate_etd"),
            },
        ),
        "generate_etd_ecomap_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_etd_ecomap_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "percentile_colormap",
                    "opacity": 0.55,
                },
                "legend": {
                    "label_column": "percentile",
                    "color_column": "percentile_colormap",
                },
                "tooltip_columns": ["percentile"],
            }
            | (params_dict.get("generate_etd_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("apply_etd_percentile_colormap"),
            },
        ),
        "combine_landdx_hr_ecomap_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_landdx_hr_ecomap_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_landdx_hr_ecomap_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_etd_ecomap_layers"),
            },
        ),
        "draw_hr_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_hr_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right"},
                "static": False,
                "title": None,
                "max_zoom": 10,
            }
            | (params_dict.get("draw_hr_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_landdx_hr_ecomap_layers"),
            },
        ),
        "persist_hr_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="persist_hr_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("persist_hr_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_hr_ecomaps"),
            },
        ),
        "create_hr_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="create_hr_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Home Range Ecomap",
            }
            | (params_dict.get("create_hr_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("persist_hr_ecomap_urls"),
            },
        ),
        "merge_hr_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="merge_hr_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("create_hr_ecomap_widgets"),
            }
            | (params_dict.get("merge_hr_ecomap_widgets") or {}),
            method="call",
        ),
        "generate_speed_rasters": Node(
            async_task=generate_speed_raster.validate()
            .handle_errors(task_instance_id="generate_speed_rasters")
            .set_executor("lithops"),
            partial={
                "dist_col": "dist_meters",
                "output_dir": DependsOn("create_output_directory"),
            }
            | (params_dict.get("generate_speed_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["gdf"],
                "argvalues": DependsOn("split_trajectories_by_group"),
            },
        ),
        "extract_speed_rasters": Node(
            async_task=retrieve_feature_gdf.validate()
            .handle_errors(task_instance_id="extract_speed_rasters")
            .set_executor("lithops"),
            partial=(params_dict.get("extract_speed_rasters") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["file_path"],
                "argvalues": DependsOn("generate_speed_rasters"),
            },
        ),
        "sort_speed_features_by_value": Node(
            async_task=sort_values.validate()
            .handle_errors(task_instance_id="sort_speed_features_by_value")
            .set_executor("lithops"),
            partial={
                "column_name": "value",
                "na_position": "last",
            }
            | (params_dict.get("sort_speed_features_by_value") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("extract_speed_rasters"),
            },
        ),
        "classify_speed_features": Node(
            async_task=apply_classification.validate()
            .handle_errors(task_instance_id="classify_speed_features")
            .set_executor("lithops"),
            partial={
                "input_column_name": "value",
                "output_column_name": "bins",
                "classification_options": {"scheme": "natural_breaks", "k": 6},
                "label_options": {"label_ranges": False, "label_decimals": 1},
            }
            | (params_dict.get("classify_speed_features") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("sort_speed_features_by_value"),
            },
        ),
        "apply_speed_raster_colormap": Node(
            async_task=apply_color_map.validate()
            .handle_errors(task_instance_id="apply_speed_raster_colormap")
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "speedraster_bins_colors",
                "colormap": [
                    "#1a9850",
                    "#91cf60",
                    "#d9ef8b",
                    "#fee08b",
                    "#fc8d59",
                    "#d73027",
                ],
            }
            | (params_dict.get("apply_speed_raster_colormap") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("classify_speed_features"),
            },
        ),
        "format_speed_raster_labels": Node(
            async_task=map_values_with_unit.validate()
            .handle_errors(task_instance_id="format_speed_raster_labels")
            .set_executor("lithops"),
            partial={
                "input_column_name": "bins",
                "output_column_name": "bins_formatted",
                "original_unit": "km/h",
                "new_unit": "km/h",
                "decimal_places": 1,
            }
            | (params_dict.get("format_speed_raster_labels") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["df"],
                "argvalues": DependsOn("apply_speed_raster_colormap"),
            },
        ),
        "generate_raster_layers": Node(
            async_task=create_polygon_layer.validate()
            .handle_errors(task_instance_id="generate_raster_layers")
            .skipif(
                conditions=[
                    any_is_empty_df,
                    any_dependency_skipped,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "layer_style": {
                    "fill_color_column": "speedraster_bins_colors",
                    "opacity": 0.55,
                },
                "legend": {
                    "label_column": "bins_formatted",
                    "color_column": "speedraster_bins_colors",
                },
                "tooltip_columns": ["value", "bins", "speedraster_bins_colors"],
            }
            | (params_dict.get("generate_raster_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geodataframe"],
                "argvalues": DependsOn("format_speed_raster_labels"),
            },
        ),
        "combine_seasonal_raster_layers": Node(
            async_task=combine_map_layers.validate()
            .handle_errors(task_instance_id="combine_seasonal_raster_layers")
            .set_executor("lithops"),
            partial={
                "static_layers": DependsOn("create_styled_landdx_layers"),
            }
            | (params_dict.get("combine_seasonal_raster_layers") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["grouped_layers"],
                "argvalues": DependsOn("generate_raster_layers"),
            },
        ),
        "draw_speed_raster_ecomaps": Node(
            async_task=draw_ecomap.validate()
            .handle_errors(task_instance_id="draw_speed_raster_ecomaps")
            .set_executor("lithops"),
            partial={
                "tile_layers": DependsOn("configure_base_maps"),
                "north_arrow_style": {"placement": "top-left"},
                "legend_style": {"placement": "bottom-right"},
                "static": False,
                "title": None,
                "max_zoom": 10,
            }
            | (params_dict.get("draw_speed_raster_ecomaps") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["geo_layers"],
                "argvalues": DependsOn("combine_seasonal_raster_layers"),
            },
        ),
        "speed_raster_ecomap_urls": Node(
            async_task=persist_text.validate()
            .handle_errors(task_instance_id="speed_raster_ecomap_urls")
            .set_executor("lithops"),
            partial={
                "root_path": os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
            }
            | (params_dict.get("speed_raster_ecomap_urls") or {}),
            method="mapvalues",
            kwargs={
                "argnames": ["text"],
                "argvalues": DependsOn("draw_speed_raster_ecomaps"),
            },
        ),
        "speed_raster_ecomap_widgets": Node(
            async_task=create_map_widget_single_view.validate()
            .handle_errors(task_instance_id="speed_raster_ecomap_widgets")
            .skipif(
                conditions=[
                    never,
                ],
                unpack_depth=1,
            )
            .set_executor("lithops"),
            partial={
                "title": "Speed Raster Ecomap",
            }
            | (params_dict.get("speed_raster_ecomap_widgets") or {}),
            method="map",
            kwargs={
                "argnames": ["view", "data"],
                "argvalues": DependsOn("speed_raster_ecomap_urls"),
            },
        ),
        "speedraster_ecomap_widgets": Node(
            async_task=merge_widget_views.validate()
            .handle_errors(task_instance_id="speedraster_ecomap_widgets")
            .set_executor("lithops"),
            partial={
                "widgets": DependsOn("speed_raster_ecomap_widgets"),
            }
            | (params_dict.get("speedraster_ecomap_widgets") or {}),
            method="call",
        ),
        "mapbook_dashboard": Node(
            async_task=gather_dashboard.validate()
            .handle_errors(task_instance_id="mapbook_dashboard")
            .set_executor("lithops"),
            partial={
                "details": DependsOn("initialize_workflow_metadata"),
                "widgets": DependsOnSequence(
                    [
                        DependsOn("merge_speed_ecomap_widgets"),
                        DependsOn("merge_day_night_ecomap_widgets"),
                        DependsOn("merge_quarter_ecomap_widgets"),
                        DependsOn("merge_hr_ecomap_widgets"),
                        DependsOn("speedraster_ecomap_widgets"),
                    ],
                ),
                "time_range": DependsOn("define_time_range"),
                "groupers": DependsOn("configure_grouping_strategy"),
            }
            | (params_dict.get("mapbook_dashboard") or {}),
            method="call",
        ),
    }
    graph = Graph(dependencies=dependencies, nodes=nodes)
    results = graph.execute()
    return results
