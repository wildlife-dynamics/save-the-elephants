# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details


# ruff: noqa: E402

# %% [markdown]
# # Mapbook Report
# TODO: top level description

# %% [markdown]
# ## Imports

import os
from ecoscope_workflows_core.tasks.config import set_workflow_details
from ecoscope_workflows_core.tasks.filter import set_time_range
from ecoscope_workflows_core.tasks.groupby import set_groupers
from ecoscope_workflows_ext_ecoscope.tasks.results import set_base_maps
from ecoscope_workflows_ext_ste.tasks import create_directory
from ecoscope_workflows_ext_ste.tasks import download_land_dx
from ecoscope_workflows_ext_ste.tasks import load_landdx_aoi
from ecoscope_workflows_ext_ste.tasks import split_gdf_by_column
from ecoscope_workflows_ext_ste.tasks import annotate_gdf_dict_with_geometry_type
from ecoscope_workflows_ext_ste.tasks import create_map_layers_from_annotated_dict
from ecoscope_workflows_core.tasks.io import set_er_connection
from ecoscope_workflows_core.tasks.io import set_gee_connection
from ecoscope_workflows_ext_ecoscope.tasks.io import get_subjectgroup_observations
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import process_relocations
from ecoscope_workflows_ext_ecoscope.tasks.transformation import classify_is_night
from ecoscope_workflows_ext_ecoscope.tasks.preprocessing import (
    relocations_to_trajectory,
)
from ecoscope_workflows_core.tasks.transformation import add_temporal_index
from ecoscope_workflows_ext_ecoscope.tasks.transformation import apply_classification
from ecoscope_workflows_ext_ste.tasks import label_quarter_status
from ecoscope_workflows_ext_ecoscope.tasks.analysis import (
    calculate_elliptical_time_density,
)
from ecoscope_workflows_ext_ecoscope.tasks.io import determine_season_windows
from ecoscope_workflows_ext_ste.tasks import create_seasonal_labels
from ecoscope_workflows_ext_ecoscope.tasks.io import persist_df
from ecoscope_workflows_core.tasks.groupby import split_groups
from ecoscope_workflows_core.tasks.transformation import sort_values
from ecoscope_workflows_ext_ecoscope.tasks.transformation import apply_color_map
from ecoscope_workflows_core.tasks.transformation import map_values_with_unit
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polyline_layer
from ecoscope_workflows_core.tasks.skip import any_is_empty_df
from ecoscope_workflows_core.tasks.skip import any_dependency_skipped
from ecoscope_workflows_ext_ste.tasks import combine_map_layers
from ecoscope_workflows_ext_ecoscope.tasks.results import draw_ecomap
from ecoscope_workflows_core.tasks.io import persist_text
from ecoscope_workflows_core.tasks.results import create_map_widget_single_view
from ecoscope_workflows_core.tasks.skip import never
from ecoscope_workflows_core.tasks.results import merge_widget_views
from ecoscope_workflows_ext_ste.tasks import calculate_etd_by_groups
from ecoscope_workflows_ext_ste.tasks import view_df
from ecoscope_workflows_ext_ecoscope.tasks.results import create_polygon_layer
from ecoscope_workflows_ext_ste.tasks import generate_speed_raster
from ecoscope_workflows_ext_ste.tasks import retrieve_feature_gdf
from ecoscope_workflows_core.tasks.results import gather_dashboard

# %% [markdown]
# ## Initialize Workflow Metadata

# %%
# parameters

initialize_workflow_metadata_params = dict(
    name=...,
    description=...,
    image_url=...,
)

# %%
# call the task


initialize_workflow_metadata = (
    set_workflow_details.handle_errors(task_instance_id="initialize_workflow_metadata")
    .partial(**initialize_workflow_metadata_params)
    .call()
)


# %% [markdown]
# ## Define Time Range

# %%
# parameters

define_time_range_params = dict(
    since=...,
    until=...,
)

# %%
# call the task


define_time_range = (
    set_time_range.handle_errors(task_instance_id="define_time_range")
    .partial(time_format="%d %b %Y %H:%M:%S %Z", **define_time_range_params)
    .call()
)


# %% [markdown]
# ## Configure Grouping Strategy

# %%
# parameters

configure_grouping_strategy_params = dict(
    groupers=...,
)

# %%
# call the task


configure_grouping_strategy = (
    set_groupers.handle_errors(task_instance_id="configure_grouping_strategy")
    .partial(**configure_grouping_strategy_params)
    .call()
)


# %% [markdown]
# ## Configure Base Map Layers

# %%
# parameters

configure_base_maps_params = dict(
    base_maps=...,
)

# %%
# call the task


configure_base_maps = (
    set_base_maps.handle_errors(task_instance_id="configure_base_maps")
    .partial(**configure_base_maps_params)
    .call()
)


# %% [markdown]
# ## Create Output Directory

# %%
# parameters

create_output_directory_params = dict(
    path_name=...,
)

# %%
# call the task


create_output_directory = (
    create_directory.handle_errors(task_instance_id="create_output_directory")
    .partial(**create_output_directory_params)
    .call()
)


# %% [markdown]
# ## Retrieve and Unpack LandDx Database

# %%
# parameters

retrieve_landdx_database_params = dict(
    url=...,
    overwrite_existing=...,
    unzip=...,
)

# %%
# call the task


retrieve_landdx_database = (
    download_land_dx.handle_errors(task_instance_id="retrieve_landdx_database")
    .partial(path=create_output_directory, **retrieve_landdx_database_params)
    .call()
)


# %% [markdown]
# ## Load AOI from landDx

# %%
# parameters

load_aoi_params = dict(
    aoi=...,
)

# %%
# call the task


load_aoi = (
    load_landdx_aoi.handle_errors(task_instance_id="load_aoi")
    .partial(map_path=retrieve_landdx_database, **load_aoi_params)
    .call()
)


# %% [markdown]
# ## Split LandDx Layers by Type

# %%
# parameters

split_landdx_by_type_params = dict()

# %%
# call the task


split_landdx_by_type = (
    split_gdf_by_column.handle_errors(task_instance_id="split_landdx_by_type")
    .partial(gdf=load_aoi, column="type", **split_landdx_by_type_params)
    .call()
)


# %% [markdown]
# ## Annotate Geometry Types

# %%
# parameters

annotate_geometry_types_params = dict()

# %%
# call the task


annotate_geometry_types = (
    annotate_gdf_dict_with_geometry_type.handle_errors(
        task_instance_id="annotate_geometry_types"
    )
    .partial(gdf_dict=split_landdx_by_type, **annotate_geometry_types_params)
    .call()
)


# %% [markdown]
# ## Style LandDx Map Layers

# %%
# parameters

create_styled_landdx_layers_params = dict(
    style_config=...,
)

# %%
# call the task


create_styled_landdx_layers = (
    create_map_layers_from_annotated_dict.handle_errors(
        task_instance_id="create_styled_landdx_layers"
    )
    .partial(
        annotated_dict=annotate_geometry_types, **create_styled_landdx_layers_params
    )
    .call()
)


# %% [markdown]
# ## Connect to EarthRanger Instance

# %%
# parameters

er_client_name_params = dict(
    data_source=...,
)

# %%
# call the task


er_client_name = (
    set_er_connection.handle_errors(task_instance_id="er_client_name")
    .partial(**er_client_name_params)
    .call()
)


# %% [markdown]
# ## Connect to EE

# %%
# parameters

gee_project_name_params = dict(
    data_source=...,
)

# %%
# call the task


gee_project_name = (
    set_gee_connection.handle_errors(task_instance_id="gee_project_name")
    .partial(**gee_project_name_params)
    .call()
)


# %% [markdown]
# ## Get subject Group Observations from ER

# %%
# parameters

subject_observations_params = dict(
    subject_group_name=...,
)

# %%
# call the task


subject_observations = (
    get_subjectgroup_observations.handle_errors(task_instance_id="subject_observations")
    .partial(
        client=er_client_name,
        time_range=define_time_range,
        raise_on_empty=False,
        include_details=False,
        include_subjectsource_details=False,
        **subject_observations_params,
    )
    .call()
)


# %% [markdown]
# ## Transform Observations to Relocations

# %%
# parameters

subject_reloc_params = dict()

# %%
# call the task


subject_reloc = (
    process_relocations.handle_errors(task_instance_id="subject_reloc")
    .partial(
        observations=subject_observations,
        relocs_columns=[
            "groupby_col",
            "fixtime",
            "junk_status",
            "geometry",
            "extra__subject__name",
            "extra__subject__subject_subtype",
            "extra__subject__sex",
            "extra__created_at",
        ],
        filter_point_coords=[
            {"x": 180.0, "y": 90.0},
            {"x": 0.0, "y": 0.0},
            {"x": 1.0, "y": 1.0},
        ],
        **subject_reloc_params,
    )
    .call()
)


# %% [markdown]
# ## Annotate Relocations with Day/Night Labels

# %%
# parameters

annotate_day_night_params = dict()

# %%
# call the task


annotate_day_night = (
    classify_is_night.handle_errors(task_instance_id="annotate_day_night")
    .partial(relocations=subject_reloc, **annotate_day_night_params)
    .call()
)


# %% [markdown]
# ## Convert Relocations to Trajectories

# %%
# parameters

convert_to_trajectories_params = dict(
    trajectory_segment_filter=...,
)

# %%
# call the task


convert_to_trajectories = (
    relocations_to_trajectory.handle_errors(task_instance_id="convert_to_trajectories")
    .partial(relocations=annotate_day_night, **convert_to_trajectories_params)
    .call()
)


# %% [markdown]
# ## Add Temporal Index to Trajectories

# %%
# parameters

add_temporal_index_to_traj_params = dict()

# %%
# call the task


add_temporal_index_to_traj = (
    add_temporal_index.handle_errors(task_instance_id="add_temporal_index_to_traj")
    .partial(
        df=convert_to_trajectories,
        time_col="segment_start",
        groupers=configure_grouping_strategy,
        cast_to_datetime=True,
        format="mixed",
        **add_temporal_index_to_traj_params,
    )
    .call()
)


# %% [markdown]
# ## Classify Trajectories by Speed

# %%
# parameters

classify_trajectory_speed_bins_params = dict()

# %%
# call the task


classify_trajectory_speed_bins = (
    apply_classification.handle_errors(
        task_instance_id="classify_trajectory_speed_bins"
    )
    .partial(
        df=add_temporal_index_to_traj,
        input_column_name="speed_kmhr",
        output_column_name="speed_bins",
        classification_options={"scheme": "equal_interval", "k": 6},
        label_options={"label_ranges": False, "label_decimals": 1},
        **classify_trajectory_speed_bins_params,
    )
    .call()
)


# %% [markdown]
# ## Label Trajectories by Quarter

# %%
# parameters

label_trajectory_quarters_params = dict()

# %%
# call the task


label_trajectory_quarters = (
    label_quarter_status.handle_errors(task_instance_id="label_trajectory_quarters")
    .partial(
        gdf=classify_trajectory_speed_bins,
        timestamp_col="segment_start",
        **label_trajectory_quarters_params,
    )
    .call()
)


# %% [markdown]
# ## Generate Seasonal Home Range ETD

# %%
# parameters

generate_seasonal_etd_params = dict(
    auto_scale_or_custom_cell_size=...,
    max_speed_factor=...,
    expansion_factor=...,
)

# %%
# call the task


generate_seasonal_etd = (
    calculate_elliptical_time_density.handle_errors(
        task_instance_id="generate_seasonal_etd"
    )
    .partial(
        crs="ESRI:53042",
        percentiles=[50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
        nodata_value="nan",
        band_count=1,
        trajectory_gdf=label_trajectory_quarters,
        **generate_seasonal_etd_params,
    )
    .call()
)


# %% [markdown]
# ## Determine Seasonal Windows

# %%
# parameters

determine_seasonal_windows_params = dict()

# %%
# call the task


determine_seasonal_windows = (
    determine_season_windows.handle_errors(
        task_instance_id="determine_seasonal_windows"
    )
    .partial(
        client=gee_project_name,
        roi=generate_seasonal_etd,
        time_range=define_time_range,
        **determine_seasonal_windows_params,
    )
    .call()
)


# %% [markdown]
# ## Generate Seasonal labels

# %%
# parameters

add_season_labels_params = dict()

# %%
# call the task


add_season_labels = (
    create_seasonal_labels.handle_errors(task_instance_id="add_season_labels")
    .partial(
        traj=label_trajectory_quarters,
        total_percentiles=determine_seasonal_windows,
        **add_season_labels_params,
    )
    .call()
)


# %% [markdown]
# ## Persist Trajectories as GPKG

# %%
# parameters

persist_traj_df_params = dict(
    filename=...,
)

# %%
# call the task


persist_traj_df = (
    persist_df.handle_errors(task_instance_id="persist_traj_df")
    .partial(
        df=add_season_labels,
        filetype="gpkg",
        root_path=create_output_directory,
        **persist_traj_df_params,
    )
    .call()
)


# %% [markdown]
# ## Persist Relocations as GPKG

# %%
# parameters

persist_relocs_df_params = dict(
    filename=...,
)

# %%
# call the task


persist_relocs_df = (
    persist_df.handle_errors(task_instance_id="persist_relocs_df")
    .partial(
        df=annotate_day_night,
        filetype="gpkg",
        root_path=create_output_directory,
        **persist_relocs_df_params,
    )
    .call()
)


# %% [markdown]
# ## Split Trajectories by Group

# %%
# parameters

split_trajectories_by_group_params = dict()

# %%
# call the task


split_trajectories_by_group = (
    split_groups.handle_errors(task_instance_id="split_trajectories_by_group")
    .partial(
        df=add_season_labels,
        groupers=configure_grouping_strategy,
        **split_trajectories_by_group_params,
    )
    .call()
)


# %% [markdown]
# ## Sort Trajectories by Speed Bins

# %%
# parameters

sort_trajectories_by_speed_params = dict(
    ascending=...,
)

# %%
# call the task


sort_trajectories_by_speed = (
    sort_values.handle_errors(task_instance_id="sort_trajectories_by_speed")
    .partial(
        column_name="speed_bins",
        na_position="last",
        **sort_trajectories_by_speed_params,
    )
    .mapvalues(argnames=["df"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Apply Colormap to Speed Bins

# %%
# parameters

apply_speed_colormap_params = dict()

# %%
# call the task


apply_speed_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_speed_colormap")
    .partial(
        input_column_name="speed_bins",
        output_column_name="speed_bins_colormap",
        colormap=["#1a9850", "#91cf60", "#d9ef8b", "#fee08b", "#fc8d59", "#d73027"],
        **apply_speed_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_trajectories_by_speed)
)


# %% [markdown]
# ## Format Speed Bins for Legend

# %%
# parameters

format_speed_bin_labels_params = dict()

# %%
# call the task


format_speed_bin_labels = (
    map_values_with_unit.handle_errors(task_instance_id="format_speed_bin_labels")
    .partial(
        input_column_name="speed_bins",
        output_column_name="speed_bins_formatted",
        original_unit="km/h",
        new_unit="km/h",
        decimal_places=1,
        **format_speed_bin_labels_params,
    )
    .mapvalues(argnames=["df"], argvalues=apply_speed_colormap)
)


# %% [markdown]
# ## Format Speed Values for Display

# %%
# parameters

format_speed_values_params = dict()

# %%
# call the task


format_speed_values = (
    map_values_with_unit.handle_errors(task_instance_id="format_speed_values")
    .partial(
        input_column_name="speed_kmhr",
        output_column_name="speed_kmhr",
        original_unit="km/h",
        new_unit="km/h",
        decimal_places=1,
        **format_speed_values_params,
    )
    .mapvalues(argnames=["df"], argvalues=format_speed_bin_labels)
)


# %% [markdown]
# ## Generate Speed Ecomap Layers

# %%
# parameters

generate_speed_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_speed_ecomap_layers = (
    create_polyline_layer.handle_errors(task_instance_id="generate_speed_ecomap_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={"color_column": "speed_bins_colormap"},
        legend={
            "label_column": "speed_bins_formatted",
            "color_column": "speed_bins_colormap",
        },
        tooltip_columns=[
            "extra__is_night",
            "extra__name",
            "segment_start",
            "dist_meters",
            "timespan_seconds",
            "extra__sex",
        ],
        **generate_speed_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=format_speed_values)
)


# %% [markdown]
# ## Combine LandDx and Speed Ecomap Layers

# %%
# parameters

combine_landdx_speed_layers_params = dict()

# %%
# call the task


combine_landdx_speed_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_landdx_speed_layers")
    .partial(
        static_layers=create_styled_landdx_layers, **combine_landdx_speed_layers_params
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_speed_ecomap_layers)
)


# %% [markdown]
# ## Draw Speed Ecomaps by Group

# %%
# parameters

draw_speed_ecomaps_params = dict(
    view_state=...,
)

# %%
# call the task


draw_speed_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_speed_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_speed_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers"], argvalues=combine_landdx_speed_layers)
)


# %% [markdown]
# ## Persist Speed Ecomap HTML Paths

# %%
# parameters

persist_speed_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_speed_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_speed_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_speed_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_speed_ecomaps)
)


# %% [markdown]
# ## Create Speed Ecomap Widgets

# %%
# parameters

create_speed_ecomap_widgets_params = dict()

# %%
# call the task


create_speed_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_speed_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Speed Ecomap", **create_speed_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_speed_ecomap_urls)
)


# %% [markdown]
# ## Merge Speed Ecomap Widgets

# %%
# parameters

merge_speed_ecomap_widgets_params = dict()

# %%
# call the task


merge_speed_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_speed_ecomap_widgets")
    .partial(widgets=create_speed_ecomap_widgets, **merge_speed_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Sort Trajectories by Night/Day

# %%
# parameters

sort_trajectories_by_day_night_params = dict()

# %%
# call the task


sort_trajectories_by_day_night = (
    sort_values.handle_errors(task_instance_id="sort_trajectories_by_day_night")
    .partial(
        column_name="extra__is_night",
        ascending=False,
        na_position="last",
        **sort_trajectories_by_day_night_params,
    )
    .mapvalues(argnames=["df"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Apply Color to Trajectories by Day/Night

# %%
# parameters

apply_day_night_colormap_params = dict()

# %%
# call the task


apply_day_night_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_day_night_colormap")
    .partial(
        colormap=["#292965", "#e7a553"],
        input_column_name="extra__is_night",
        output_column_name="day_night_colors",
        **apply_day_night_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_trajectories_by_day_night)
)


# %% [markdown]
# ## Create Day/Night Ecomap Layers

# %%
# parameters

generate_day_night_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_day_night_ecomap_layers = (
    create_polyline_layer.handle_errors(
        task_instance_id="generate_day_night_ecomap_layers"
    )
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={"color_column": "day_night_colors"},
        legend={"labels": ["Night", "Day"], "colors": ["#292965", "#e7a553"]},
        tooltip_columns=["extra__is_night", "extra__name", "extra__sex"],
        **generate_day_night_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=apply_day_night_colormap)
)


# %% [markdown]
# ## Combine LandDx and Day/Night Ecomap Layers

# %%
# parameters

combine_landdx_dn_ecomap_layers_params = dict()

# %%
# call the task


combine_landdx_dn_ecomap_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_landdx_dn_ecomap_layers")
    .partial(
        static_layers=create_styled_landdx_layers,
        **combine_landdx_dn_ecomap_layers_params,
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_day_night_ecomap_layers)
)


# %% [markdown]
# ## Draw Day/Night Ecomaps by Group

# %%
# parameters

draw_day_night_ecomaps_params = dict(
    view_state=...,
)

# %%
# call the task


draw_day_night_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_day_night_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_day_night_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers"], argvalues=combine_landdx_dn_ecomap_layers)
)


# %% [markdown]
# ## Persist Day/Night Ecomap HTML Paths

# %%
# parameters

persist_day_night_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_day_night_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_day_night_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_day_night_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_day_night_ecomaps)
)


# %% [markdown]
# ## Create Day/Night Ecomap Widgets

# %%
# parameters

create_day_night_ecomap_widgets_params = dict()

# %%
# call the task


create_day_night_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_day_night_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Day/Night Ecomap", **create_day_night_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_day_night_ecomap_urls)
)


# %% [markdown]
# ## Merge Day/Night Ecomap Widgets

# %%
# parameters

merge_day_night_ecomap_widgets_params = dict()

# %%
# call the task


merge_day_night_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_day_night_ecomap_widgets")
    .partial(
        widgets=create_day_night_ecomap_widgets, **merge_day_night_ecomap_widgets_params
    )
    .call()
)


# %% [markdown]
# ## Sort Trajectories by Quarter Status

# %%
# parameters

sort_trajs_by_quarter_status_params = dict()

# %%
# call the task


sort_trajs_by_quarter_status = (
    sort_values.handle_errors(task_instance_id="sort_trajs_by_quarter_status")
    .partial(
        column_name="quarter_status",
        ascending=False,
        na_position="last",
        **sort_trajs_by_quarter_status_params,
    )
    .mapvalues(argnames=["df"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Apply Color to Trajectories by Quarter Status

# %%
# parameters

apply_quarter_status_colormap_params = dict()

# %%
# call the task


apply_quarter_status_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_quarter_status_colormap")
    .partial(
        colormap=["#2f4f4f", "#ff8c00"],
        input_column_name="quarter_status",
        output_column_name="quarter_status_colors",
        **apply_quarter_status_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_trajs_by_quarter_status)
)


# %% [markdown]
# ## Create Quarter Status Ecomap Layers

# %%
# parameters

generate_quarter_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_quarter_ecomap_layers = (
    create_polyline_layer.handle_errors(
        task_instance_id="generate_quarter_ecomap_layers"
    )
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={"color_column": "quarter_status_colors"},
        legend={
            "labels": ["Previous Quarter", "Current Quarter"],
            "colors": ["#2f4f4f", "#ff8c00"],
        },
        tooltip_columns=[
            "extra__is_night",
            "extra__name",
            "extra__sex",
            "quarter_status",
            "day_night_colors",
        ],
        **generate_quarter_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=apply_quarter_status_colormap)
)


# %% [markdown]
# ## Combine LandDx and Quarter Status Ecomap Layers

# %%
# parameters

combine_quarter_ecomap_layers_params = dict()

# %%
# call the task


combine_quarter_ecomap_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_quarter_ecomap_layers")
    .partial(
        static_layers=create_styled_landdx_layers,
        **combine_quarter_ecomap_layers_params,
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_quarter_ecomap_layers)
)


# %% [markdown]
# ## Draw Quarter Status Ecomaps by Group

# %%
# parameters

draw_quarter_status_ecomaps_params = dict(
    view_state=...,
)

# %%
# call the task


draw_quarter_status_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_quarter_status_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_quarter_status_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers"], argvalues=combine_quarter_ecomap_layers)
)


# %% [markdown]
# ## Persist Quarter Status Ecomap HTML Paths

# %%
# parameters

persist_quarter_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_quarter_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_quarter_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_quarter_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_quarter_status_ecomaps)
)


# %% [markdown]
# ## Create Quarter Status Ecomap Widgets

# %%
# parameters

create_quarter_ecomap_widgets_params = dict()

# %%
# call the task


create_quarter_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_quarter_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(
        title="Subject Group Quarter Movement Map",
        **create_quarter_ecomap_widgets_params,
    )
    .map(argnames=["view", "data"], argvalues=persist_quarter_ecomap_urls)
)


# %% [markdown]
# ## Merge Quarter Status Ecomap Widgets

# %%
# parameters

merge_quarter_ecomap_widgets_params = dict()

# %%
# call the task


merge_quarter_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_quarter_ecomap_widgets")
    .partial(
        widgets=create_quarter_ecomap_widgets, **merge_quarter_ecomap_widgets_params
    )
    .call()
)


# %% [markdown]
# ## Generate Home Range Ecomaps

# %%
# parameters

generate_etd_params = dict(
    auto_scale_or_custom_cell_size=...,
    max_speed_factor=...,
    expansion_factor=...,
)

# %%
# call the task


generate_etd = (
    calculate_etd_by_groups.handle_errors(task_instance_id="generate_etd")
    .partial(
        crs="ESRI:53042",
        percentiles=[50.0, 60.0, 70.0, 80.0, 90.0, 95.0, 99.0],
        nodata_value="nan",
        band_count=1,
        include_groups=True,
        groupby_cols=["season"],
        **generate_etd_params,
    )
    .mapvalues(argnames=["trajectory_gdf"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## inspect HR gdf

# %%
# parameters

inspect_hr_df_params = dict()

# %%
# call the task


inspect_hr_df = (
    view_df.handle_errors(task_instance_id="inspect_hr_df")
    .partial(name="subject-HR-etd", **inspect_hr_df_params)
    .mapvalues(argnames=["gdf"], argvalues=generate_etd)
)


# %% [markdown]
# ## Apply Colormap to Home Range Percentiles

# %%
# parameters

apply_etd_percentile_colormap_params = dict()

# %%
# call the task


apply_etd_percentile_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_etd_percentile_colormap")
    .partial(
        input_column_name="percentile",
        colormap="RdYlGn",
        output_column_name="percentile_colormap",
        **apply_etd_percentile_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=generate_etd)
)


# %% [markdown]
# ## Create Home Range Ecomap Layers

# %%
# parameters

generate_etd_ecomap_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_etd_ecomap_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_etd_ecomap_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={"fill_color_column": "percentile_colormap", "opacity": 0.55},
        legend={"label_column": "percentile", "color_column": "percentile_colormap"},
        tooltip_columns=["percentile"],
        **generate_etd_ecomap_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=apply_etd_percentile_colormap)
)


# %% [markdown]
# ## Combine LandDx and Home Range Ecomap Layers

# %%
# parameters

combine_landdx_hr_ecomap_layers_params = dict()

# %%
# call the task


combine_landdx_hr_ecomap_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_landdx_hr_ecomap_layers")
    .partial(
        static_layers=create_styled_landdx_layers,
        **combine_landdx_hr_ecomap_layers_params,
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_etd_ecomap_layers)
)


# %% [markdown]
# ## Draw Home Range Ecomaps by Group

# %%
# parameters

draw_hr_ecomaps_params = dict(
    view_state=...,
)

# %%
# call the task


draw_hr_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_hr_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_hr_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers"], argvalues=combine_landdx_hr_ecomap_layers)
)


# %% [markdown]
# ## Persist Home Range Ecomap HTML Paths

# %%
# parameters

persist_hr_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


persist_hr_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="persist_hr_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **persist_hr_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_hr_ecomaps)
)


# %% [markdown]
# ## Create Home Range Ecomap Widgets

# %%
# parameters

create_hr_ecomap_widgets_params = dict()

# %%
# call the task


create_hr_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="create_hr_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Home Range Ecomap", **create_hr_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=persist_hr_ecomap_urls)
)


# %% [markdown]
# ## Merge Home Range Ecomap Widgets

# %%
# parameters

merge_hr_ecomap_widgets_params = dict()

# %%
# call the task


merge_hr_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="merge_hr_ecomap_widgets")
    .partial(widgets=create_hr_ecomap_widgets, **merge_hr_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Generate Subject Speed Rasters

# %%
# parameters

generate_speed_rasters_params = dict(
    filename=...,
    resolution=...,
    radius=...,
    cutoff=...,
    tortuosity_length=...,
)

# %%
# call the task


generate_speed_rasters = (
    generate_speed_raster.handle_errors(task_instance_id="generate_speed_rasters")
    .partial(
        dist_col="dist_meters",
        output_dir=create_output_directory,
        **generate_speed_rasters_params,
    )
    .mapvalues(argnames=["gdf"], argvalues=split_trajectories_by_group)
)


# %% [markdown]
# ## Extract Features from Speed Raster TIFFs

# %%
# parameters

extract_speed_rasters_params = dict()

# %%
# call the task


extract_speed_rasters = (
    retrieve_feature_gdf.handle_errors(task_instance_id="extract_speed_rasters")
    .partial(**extract_speed_rasters_params)
    .mapvalues(argnames=["file_path"], argvalues=generate_speed_rasters)
)


# %% [markdown]
# ## Sort Speed Features by Value

# %%
# parameters

sort_speed_features_by_value_params = dict(
    ascending=...,
)

# %%
# call the task


sort_speed_features_by_value = (
    sort_values.handle_errors(task_instance_id="sort_speed_features_by_value")
    .partial(
        column_name="value", na_position="last", **sort_speed_features_by_value_params
    )
    .mapvalues(argnames=["df"], argvalues=extract_speed_rasters)
)


# %% [markdown]
# ## Classify Speed Feature GeoDataFrames

# %%
# parameters

classify_speed_features_params = dict()

# %%
# call the task


classify_speed_features = (
    apply_classification.handle_errors(task_instance_id="classify_speed_features")
    .partial(
        input_column_name="value",
        output_column_name="bins",
        classification_options={"scheme": "natural_breaks", "k": 6},
        label_options={"label_ranges": False, "label_decimals": 1},
        **classify_speed_features_params,
    )
    .mapvalues(argnames=["df"], argvalues=sort_speed_features_by_value)
)


# %% [markdown]
# ## Apply Colormap to Speed Raster Bins

# %%
# parameters

apply_speed_raster_colormap_params = dict()

# %%
# call the task


apply_speed_raster_colormap = (
    apply_color_map.handle_errors(task_instance_id="apply_speed_raster_colormap")
    .partial(
        input_column_name="bins",
        output_column_name="speedraster_bins_colors",
        colormap=["#1a9850", "#91cf60", "#d9ef8b", "#fee08b", "#fc8d59", "#d73027"],
        **apply_speed_raster_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=classify_speed_features)
)


# %% [markdown]
# ## Format Speed Raster Bin Labels

# %%
# parameters

format_speed_raster_labels_params = dict()

# %%
# call the task


format_speed_raster_labels = (
    map_values_with_unit.handle_errors(task_instance_id="format_speed_raster_labels")
    .partial(
        input_column_name="bins",
        output_column_name="bins_formatted",
        original_unit="km/h",
        new_unit="km/h",
        decimal_places=1,
        **format_speed_raster_labels_params,
    )
    .mapvalues(argnames=["df"], argvalues=apply_speed_raster_colormap)
)


# %% [markdown]
# ## Create Speed Raster Map Layers

# %%
# parameters

generate_raster_layers_params = dict(
    zoom=...,
)

# %%
# call the task


generate_raster_layers = (
    create_polygon_layer.handle_errors(task_instance_id="generate_raster_layers")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={"fill_color_column": "speedraster_bins_colors", "opacity": 0.55},
        legend={
            "label_column": "bins_formatted",
            "color_column": "speedraster_bins_colors",
        },
        tooltip_columns=["value", "bins", "speedraster_bins_colors"],
        **generate_raster_layers_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=format_speed_raster_labels)
)


# %% [markdown]
# ## Combine LandDx and SpeedRaster Map Layers

# %%
# parameters

combine_seasonal_raster_layers_params = dict()

# %%
# call the task


combine_seasonal_raster_layers = (
    combine_map_layers.handle_errors(task_instance_id="combine_seasonal_raster_layers")
    .partial(
        static_layers=create_styled_landdx_layers,
        **combine_seasonal_raster_layers_params,
    )
    .mapvalues(argnames=["grouped_layers"], argvalues=generate_raster_layers)
)


# %% [markdown]
# ## Draw Speed Raster Ecomaps by Group

# %%
# parameters

draw_speed_raster_ecomaps_params = dict(
    view_state=...,
)

# %%
# call the task


draw_speed_raster_ecomaps = (
    draw_ecomap.handle_errors(task_instance_id="draw_speed_raster_ecomaps")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right"},
        static=False,
        title=None,
        max_zoom=20,
        **draw_speed_raster_ecomaps_params,
    )
    .mapvalues(argnames=["geo_layers"], argvalues=combine_seasonal_raster_layers)
)


# %% [markdown]
# ## Persist Speed Raster Ecomap HTML Paths

# %%
# parameters

speed_raster_ecomap_urls_params = dict(
    filename=...,
)

# %%
# call the task


speed_raster_ecomap_urls = (
    persist_text.handle_errors(task_instance_id="speed_raster_ecomap_urls")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **speed_raster_ecomap_urls_params,
    )
    .mapvalues(argnames=["text"], argvalues=draw_speed_raster_ecomaps)
)


# %% [markdown]
# ## Create Speed Raster Ecomap Widgets

# %%
# parameters

speed_raster_ecomap_widgets_params = dict()

# %%
# call the task


speed_raster_ecomap_widgets = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="speed_raster_ecomap_widgets"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(title="Speed Raster Ecomap", **speed_raster_ecomap_widgets_params)
    .map(argnames=["view", "data"], argvalues=speed_raster_ecomap_urls)
)


# %% [markdown]
# ## Merge Speed Raster Ecomap Widgets

# %%
# parameters

speedraster_ecomap_widgets_params = dict()

# %%
# call the task


speedraster_ecomap_widgets = (
    merge_widget_views.handle_errors(task_instance_id="speedraster_ecomap_widgets")
    .partial(widgets=speed_raster_ecomap_widgets, **speedraster_ecomap_widgets_params)
    .call()
)


# %% [markdown]
# ## Time Density colormap

# %%
# parameters

season_colormap_params = dict()

# %%
# call the task


season_colormap = (
    apply_color_map.handle_errors(task_instance_id="season_colormap")
    .partial(
        input_column_name="season",
        output_column_name="season_colormap",
        colormap=["#f57c00", "#4cf3f7"],
        **season_colormap_params,
    )
    .mapvalues(argnames=["df"], argvalues=generate_etd)
)


# %% [markdown]
# ## Create map layers from Seasons

# %%
# parameters

season_etd_map_layer_params = dict(
    zoom=...,
)

# %%
# call the task


season_etd_map_layer = (
    create_polygon_layer.handle_errors(task_instance_id="season_etd_map_layer")
    .skipif(
        conditions=[
            any_is_empty_df,
            any_dependency_skipped,
        ],
        unpack_depth=1,
    )
    .partial(
        layer_style={"fill_color_column": "season_colormap", "opacity": 0.65},
        legend={"label_column": "season", "color_column": "season_colormap"},
        tooltip_columns=["percentile"],
        **season_etd_map_layer_params,
    )
    .mapvalues(argnames=["geodataframe"], argvalues=season_colormap)
)


# %% [markdown]
# ## Combine Map Layers

# %%
# parameters

comb_season_map_layers_params = dict()

# %%
# call the task


comb_season_map_layers = (
    combine_map_layers.handle_errors(task_instance_id="comb_season_map_layers")
    .partial(static_layers=create_styled_landdx_layers, **comb_season_map_layers_params)
    .mapvalues(argnames=["grouped_layers"], argvalues=season_etd_map_layer)
)


# %% [markdown]
# ## Draw Season Ecomap

# %%
# parameters

seasonal_ecomap_params = dict(
    view_state=...,
)

# %%
# call the task


seasonal_ecomap = (
    draw_ecomap.handle_errors(task_instance_id="seasonal_ecomap")
    .partial(
        tile_layers=configure_base_maps,
        north_arrow_style={"placement": "top-left"},
        legend_style={"placement": "bottom-right"},
        static=False,
        title=None,
        max_zoom=20,
        **seasonal_ecomap_params,
    )
    .mapvalues(argnames=["geo_layers"], argvalues=comb_season_map_layers)
)


# %% [markdown]
# ## Perist HR ecomap as text

# %%
# parameters

season_etd_ecomap_html_url_params = dict(
    filename=...,
)

# %%
# call the task


season_etd_ecomap_html_url = (
    persist_text.handle_errors(task_instance_id="season_etd_ecomap_html_url")
    .partial(
        root_path=os.environ["ECOSCOPE_WORKFLOWS_RESULTS"],
        **season_etd_ecomap_html_url_params,
    )
    .mapvalues(argnames=["text"], argvalues=seasonal_ecomap)
)


# %% [markdown]
# ## Create Map Widgets for Trajectories

# %%
# parameters

season_etd_widgets_single_view_params = dict()

# %%
# call the task


season_etd_widgets_single_view = (
    create_map_widget_single_view.handle_errors(
        task_instance_id="season_etd_widgets_single_view"
    )
    .skipif(
        conditions=[
            never,
        ],
        unpack_depth=1,
    )
    .partial(
        title="Subject Group Home Range Map (Seasons)",
        **season_etd_widgets_single_view_params,
    )
    .map(argnames=["view", "data"], argvalues=season_etd_ecomap_html_url)
)


# %% [markdown]
# ## Merge Ecomap Widgets

# %%
# parameters

season_grouped_map_widget_params = dict()

# %%
# call the task


season_grouped_map_widget = (
    merge_widget_views.handle_errors(task_instance_id="season_grouped_map_widget")
    .partial(widgets=season_etd_widgets_single_view, **season_grouped_map_widget_params)
    .call()
)


# %% [markdown]
# ## Mapbook Dashboard

# %%
# parameters

mapbook_dashboard_params = dict()

# %%
# call the task


mapbook_dashboard = (
    gather_dashboard.handle_errors(task_instance_id="mapbook_dashboard")
    .partial(
        details=initialize_workflow_metadata,
        widgets=[
            merge_speed_ecomap_widgets,
            merge_day_night_ecomap_widgets,
            merge_quarter_ecomap_widgets,
            merge_hr_ecomap_widgets,
            speedraster_ecomap_widgets,
            season_grouped_map_widget,
        ],
        time_range=define_time_range,
        groupers=configure_grouping_strategy,
        **mapbook_dashboard_params,
    )
    .call()
)
